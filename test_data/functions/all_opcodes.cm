// Cairo-M combination test file demonstrating all compilable opcodes
// This program exercises all implemented opcodes for comprehensive testing

fn main() -> felt {
    // ╔══════════════════════════════════════════════════════════════════════════╗
    // ║                         Arithmetic Felt Opcodes                          ║
    // ╚══════════════════════════════════════════════════════════════════════════╝

    // Initialize some values for arithmetic operations
    let a = 10;
    let b = 5;
    let c = 2;
    let d = 20;

    // StoreAddFpFp: [fp + off2] = [fp + off0] + [fp + off1]
    let sum1 = a + b;
    let sum1 = a + a;
    a = a + a;

    // StoreAddFpImm: [fp + off2] = [fp + off0] + imm
    let sum2 = a + 3;
    a = a + 3;

    // StoreSubFpFp: [fp + off2] = [fp + off0] - [fp + off1]
    let diff1 = a - b;
    let diff1 = a - a;
    a = a - a;

    // StoreSubFpImm: [fp + off2] = [fp + off0] - imm
    let diff2 = a - 2;
    b = b - 2;

    // StoreMulFpFp: [fp + off2] = [fp + off0] * [fp + off1]
    let prod1 = a * b;
    let prod1 = b * b;
    b = b * b;

    // StoreMulFpImm: [fp + off2] = [fp + off0] * imm
    let prod2 = a * 4;
    a = a * 4;

    // StoreDivFpFp: [fp + off2] = [fp + off0] / [fp + off1]
    let div1 = d / b;
    let div1 = d / d;
    c = c / c;

    // StoreDivFpImm: [fp + off2] = [fp + off0] / imm
    let div2 = d / 4;
    d = d / 4;

    // StoreImm: [fp + off2] = imm (immediate store)
    let immediate = 42;

    // ╔══════════════════════════════════════════════════════════════════════════╗
    // ║                         Double Deref Opcodes                             ║
    // ╚══════════════════════════════════════════════════════════════════════════╝

    let my_arr: [felt; 4] = [0; 4];

    // StoreDoubleDerefFp
    let my_arr_0 = my_arr[0];

    // StoreDoubleDerefFpFp
    let one_felt = 1;
    let my_arr_1 = my_arr[one_felt];

    // StoreToDoubleDerefFpImm
    my_arr[0] = 42;

    // StoreToDoubleDerefFpFp
    my_arr[one_felt] = 42;

    // ╔══════════════════════════════════════════════════════════════════════════╗
    // ║                         Arithmetic U32 Opcodes                           ║
    // ╚══════════════════════════════════════════════════════════════════════════╝

    // U32StoreImm
    let x_u32: u32 = 42u32;
    let one_u32: u32 = 1u32;
    let two_pow_8: u32 = 256u32;
    let max_u16: u32 = 65535u32;       // 2^16 - 1
    let max_u32: u32 = 4294967295u32;  // 2^32 - 1

    // U32StoreAddFpImm
    let add_basic = x_u32 + 50u32;
    let add_zero = x_u32 + 0u32;
    let add_carry_16 = max_u16 + 2u32;
    let add_overflow = max_u32 + 2u32;

    // U32StoreMulFpImm
    let mul_basic = x_u32 * 5u32;
    let mul_zero = x_u32 * 0u32;
    let mul_one = x_u32 * 1u32;
    let mul_overflow_lo = max_u16 * 2u32;
    let mul_overflow_hi = max_u32 * 2u32;
    let big_mul = max_u32 * 4294967295u32; // max_u32 ** 2

    // U32StoreDivFpImm
    let div_by_smaller = x_u32 / 5u32;
    let div_by_greater = x_u32 / 43u32;
    let div_by_itself = x_u32 / 42u32;
    let div_by_one = x_u32 / 1u32;
    let div_max_u32 = max_u32 / 5u32;
    let div_quotient_is_max_u32 = max_u32 / 1u32;
    let div_remainder_is_max_u32 = one_u32 / 4294967295u32;

    // ╔══════════════════════════════════════════════════════════════════════════╗
    // ║                         Comparison U32 Opcodes                           ║
    // ╚══════════════════════════════════════════════════════════════════════════╝

    // U32StoreLtFpImm
    let is_lt1 = x_u32 < 1u32;
    let is_lt2 = x_u32 < 0u32;
    let is_lt1 = x_u32 < 42u32;
    let is_lt1 = x_u32 < 43u32;

    // U32StoreLtFpFp
    let zero = 0u32;
    let one = 1u32;
    let forty_two = 42u32;
    let forty_three = 43u32;
    let is_lt1 = x_u32 < one;
    let is_lt2 = x_u32 < zero;
    let is_lt1 = x_u32 < forty_two;
    let is_lt1 = x_u32 < forty_three;

    // ╔══════════════════════════════════════════════════════════════════════════╗
    // ║                         Arithmetic U32 FpFp Opcodes                      ║
    // ╚══════════════════════════════════════════════════════════════════════════╝

    // U32StoreAddFpFp
    let two = 2u32;
    let five = 5u32;
    let fifty = 50u32;
    let add_basic_fp_fp = x_u32 + fifty;
    let add_zero_fp_fp = x_u32 + zero;
    let add_carry_16_fp_fp = max_u16 + two;
    let add_overflow_fp_fp = max_u32 + two;

    // U32StoreMulFpFp
    let mul_basic_fp_fp = x_u32 * five;
    let mul_zero_fp_fp = x_u32 * zero;
    let mul_one_fp_fp = x_u32 * one;
    let mul_overflow_lo_fp_fp = max_u16 * two;
    let mul_overflow_hi_fp_fp = max_u32 * two;
    let big_mul_fp_fp = max_u32 * max_u32;

    // U32StoreDivFpFp
    let div_by_smaller_fp_fp = x_u32 / five;
    let div_by_greater_fp_fp = x_u32 / forty_three;
    let div_by_itself_fp_fp = x_u32 / x_u32;
    let div_by_one_fp_fp = x_u32 / one;
    let div_max_u32_fp_fp = max_u32 / five;
    let div_quotient_is_max_u32_fp_fp = max_u32 / one;
    let div_remainder_is_max_u32_fp_fp = one / max_u32;

    // ╔══════════════════════════════════════════════════════════════════════════╗
    // ║                               Jump Opcodes                               ║
    // ╚══════════════════════════════════════════════════════════════════════════╝

    // JnzFpImm
    if (a != 5) {
        a = a + 1;
    }

    // JmpAbsImm
    let counter = 0;
    loop {
        counter = counter + 1;
        if (counter == 2) {
            break;
        }
    }

    // ╔══════════════════════════════════════════════════════════════════════════╗
    // ║                               Call Opcode                                ║
    // ╚══════════════════════════════════════════════════════════════════════════╝

    // CallAbsImm
    let result = helper();

    return result;
}

fn helper() -> felt {
    return 5;
}
