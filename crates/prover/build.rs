//! # Build Script for Cairo-M Prover
//!
//! This build script generates compile-time constants for the Poseidon2 hash function.
//! It extracts the round constants and matrix parameters from the zkhash reference library
//! and converts them into Cairo-M's M31 field format.
//!
//! ## Generated Constants
//!
//! The build script creates three constant arrays in `poseidon2_constants.rs`:
//!
//! 1. **EXTERNAL_ROUND_CONSTS**: Round constants for full rounds
//! 2. **INTERNAL_ROUND_CONSTS**: Round constants for partial rounds
//! 3. **INTERNAL_MATRIX**: Matrix for the linear layer in partial rounds
//!
//! ## Field Conversion
//!
//! Constants are converted from the zkhash library's field representation to
//! Cairo-M's M31 field elements using `M31::from_u32_unchecked()` for efficiency.
//! This avoids runtime field element construction costs.

use std::path::Path;
use std::{env, fs};

use zkhash::ark_ff::PrimeField;
use zkhash::poseidon2::poseidon2_instance_m31::{MAT_DIAG16_M_1, RC16};

/// State size for Poseidon2 permutation (16 M31 elements)
const T: usize = 16;
/// Number of full rounds (4 at start + 4 at end)
const FULL_ROUNDS: usize = 8;
/// Number of partial rounds (in the middle)
const PARTIAL_ROUNDS: usize = 14;

fn main() {
    // Get the output directory where generated files should be placed
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("poseidon2_constants.rs");

    let mut content = String::new();

    // Generate header comment for the auto-generated file
    content.push_str("// Auto-generated constants for Poseidon2 hash function\n");
    content.push_str("// DO NOT EDIT - Generated by build.rs\n\n");

    // Generate EXTERNAL_ROUND_CONSTS array
    // These are round constants used in the full rounds of Poseidon2
    content.push_str(&format!(
        "pub const EXTERNAL_ROUND_CONSTS: [[M31; {}]; {}] = [\n",
        T, FULL_ROUNDS
    ));

    // First half of full rounds (applied at the beginning of the permutation)
    for round in 0..FULL_ROUNDS / 2 {
        content.push_str("    [");
        for i in 0..T {
            // Extract the u32 value from the zkhash field element
            let value = RC16[round][i].into_bigint().0[0] as u32;
            content.push_str(&format!("M31::from_u32_unchecked({})", value));
            if i < T - 1 {
                content.push_str(", ");
            }
        }
        content.push_str("],\n");
    }

    // Second half of full rounds (applied after the partial rounds)
    for round in 0..FULL_ROUNDS / 2 {
        // Skip to the correct index in the RC16 array (after partial rounds)
        let rc_index = PARTIAL_ROUNDS + FULL_ROUNDS / 2 + round;
        content.push_str("    [");
        for i in 0..T {
            let value = RC16[rc_index][i].into_bigint().0[0] as u32;
            content.push_str(&format!("M31::from_u32_unchecked({})", value));
            if i < T - 1 {
                content.push_str(", ");
            }
        }
        content.push_str("],\n");
    }

    content.push_str("];\n\n");

    // Generate INTERNAL_ROUND_CONSTS array
    // These are round constants used in the partial rounds (only for the first element)
    content.push_str(&format!(
        "pub const INTERNAL_ROUND_CONSTS: [M31; {}] = [\n",
        PARTIAL_ROUNDS
    ));
    for round in 0..PARTIAL_ROUNDS {
        // Calculate the correct index in RC16 (after first half of full rounds)
        let rc_index = FULL_ROUNDS / 2 + round;
        // In partial rounds, only the first element gets a round constant
        let value = RC16[rc_index][0].into_bigint().0[0] as u32;
        content.push_str(&format!("    M31::from_u32_unchecked({}),\n", value));
    }
    content.push_str("];\n\n");

    // Generate INTERNAL_MATRIX array
    // This is the diagonal matrix used in the linear layer of partial rounds
    content.push_str(&format!("pub const INTERNAL_MATRIX: [M31; {}] = [\n", T));
    for i in 0..T {
        // Extract diagonal element from the matrix
        let value = MAT_DIAG16_M_1[i].into_bigint().0[0] as u32;
        content.push_str(&format!("    M31::from_u32_unchecked({}),\n", value));
    }
    content.push_str("];\n");

    // Write the generated constants to the output file
    fs::write(&dest_path, content).unwrap();

    // Tell Cargo to rerun this build script if build.rs changes
    // This ensures constants are regenerated when the build script is modified
    println!("cargo:rerun-if-changed=build.rs");
}
