---
source: crates/compiler/codegen/tests/mdtest_snapshots.rs
description: "Codegen snapshot for mdtest: Multiple Functions in Cairo-M - Mathematical Operations"
input_file: mdtest/04-advanced/02-multiple-functions.md
---
Source:
fn test_math_operations() -> felt {
    let x = 4;
    let y = 3;
    return compute_expression(x, y);
}

fn compute_expression(a: felt, b: felt) -> felt {
    let power_result = power(a, b);
    let factorial_result = factorial(b);
    return power_result + factorial_result;
}

fn power(base: felt, exp: felt) -> felt {
    if exp == 0 {
        return 1;
    }
    return base * power(base, exp - 1);
}

fn factorial(n: felt) -> felt {
    if n == 0 {
        return 1;
    }
    return n * factorial(n - 1);
}
============================================================
Generated CASM:
test_math_operations:
test_math_operations:
test_math_operations_0:
   0: 9 4 0 _              // [fp + 0] = 4
   1: 9 3 4 _              // [fp + 4] = 3
   2: 4 0 0 5              // Arg 0 slot 0: [fp + 5] = [fp + 0] + 0
   3: 4 4 0 6              // Arg 1 slot 0: [fp + 6] = [fp + 4] + 0
   4: 10 8 7 _             // call compute_expression
   5: 4 7 0 -3             // Return value 0: [fp -3] = [fp + 7] + 0
   6: 11 _ _ _             // return
compute_expression:
compute_expression:
compute_expression_0:
   7: 4 -5 0 3             // Arg 0 slot 0: [fp + 3] = [fp + -5] + 0
   8: 4 -4 0 4             // Arg 1 slot 0: [fp + 4] = [fp + -4] + 0
   9: 10 6 14 _            // call power
  10: 4 -4 0 7             // Arg 0 slot 0: [fp + 7] = [fp + -4] + 0
  11: 10 9 24 _            // call factorial
  12: 0 5 8 -3             // [fp + -3] = [fp + 5] op [fp + 8]
  13: 11 _ _ _             // return
power:
  14: 14 -4 4 _            // if [fp + -4] != 0 jmp rel power_2
  15: 12 16 _ _            // jump abs power_1
power_1:
  16: 9 1 -3 _             // Return value 0: [fp -3] = 1
  17: 11 _ _ _             // return
power_2:
  18: 5 -4 1 4             // [fp + 4] = [fp + -4] op 1
  19: 4 -5 0 5             // Arg 0 slot 0: [fp + 5] = [fp + -5] + 0
  20: 4 4 0 6              // Arg 1 slot 0: [fp + 6] = [fp + 4] + 0
  21: 10 8 14 _            // call power
  22: 2 -5 7 -3            // [fp + -3] = [fp + -5] op [fp + 7]
  23: 11 _ _ _             // return
factorial:
  24: 14 -4 4 _            // if [fp + -4] != 0 jmp rel factorial_2
  25: 12 26 _ _            // jump abs factorial_1
factorial_1:
  26: 9 1 -3 _             // Return value 0: [fp -3] = 1
  27: 11 _ _ _             // return
factorial_2:
  28: 5 -4 1 3             // [fp + 3] = [fp + -4] op 1
  29: 10 5 24 _            // call factorial
  30: 2 -4 4 -3            // [fp + -3] = [fp + -4] op [fp + 4]
  31: 11 _ _ _             // return
