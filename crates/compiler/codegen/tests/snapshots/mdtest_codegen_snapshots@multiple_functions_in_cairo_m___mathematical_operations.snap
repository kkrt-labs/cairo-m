---
source: crates/compiler/codegen/tests/mdtest_snapshots.rs
description: "Codegen snapshot for mdtest: Multiple Functions in Cairo-M - Mathematical Operations"
input_file: mdtest/04-advanced/02-multiple-functions.md
---
Source:
fn test_math_operations() -> felt {
    let x = 4;
    let y = 3;
    return compute_expression(x, y);
}

fn compute_expression(a: felt, b: felt) -> felt {
    let power_result = power(a, b);
    let factorial_result = factorial(b);
    return power_result + factorial_result;
}

fn power(base: felt, exp: felt) -> felt {
    if exp == 0 {
        return 1;
    }
    return base * power(base, exp - 1);
}

fn factorial(n: felt) -> felt {
    if n == 0 {
        return 1;
    }
    return n * factorial(n - 1);
}
============================================================
Generated CASM:
test_math_operations:
test_math_operations:
test_math_operations_0:
   0: 9 4 0 _              // [fp + 0] = 4
   1: 9 3 4 _              // [fp + 4] = 3
   2: 4 0 0 5              // Arg 0 slot 0: [fp + 5] = [fp + 0] + 0
   3: 4 4 0 6              // Arg 1 slot 0: [fp + 6] = [fp + 4] + 0
   4: 10 8 7 _             // call compute_expression
   5: 4 7 0 2147483644     // Return value 0: [fp -3] = [fp + 7] + 0
   6: 11 _ _ _             // return
compute_expression:
compute_expression:
compute_expression_0:
   7: 4 2147483642 0 3     // Arg 0 slot 0: [fp + 3] = [fp + -5] + 0
   8: 4 2147483643 0 4     // Arg 1 slot 0: [fp + 4] = [fp + -4] + 0
   9: 10 6 14 _            // call power
  10: 4 2147483643 0 7     // Arg 0 slot 0: [fp + 7] = [fp + -4] + 0
  11: 10 9 29 _            // call factorial
  12: 0 5 8 2147483644     // [fp + -3] = [fp + 5] op [fp + 8]
  13: 11 _ _ _             // return
power:
  14: 4 2147483643 0 0     // [fp + 0] = [fp + -4] + (-0) (-0 as M31 -> 0)
  15: 14 0 3 _             // if [fp + 0] != 0 jmp rel not_zero_0
  16: 9 1 0 _              // [fp + 0] = 1
  17: 13 2 _ _             // jump rel end_1
not_zero_0:
  18: 9 0 0 _              // [fp + 0] = 0
end_1:
  19: 14 0 2 _             // if [fp + 0] != 0 jmp rel power_1
  20: 13 3 _ _             // jump rel power_2
power_1:
  21: 9 1 2147483644 _     // Return value 0: [fp -3] = 1
  22: 11 _ _ _             // return
power_2:
  23: 4 2147483643 2147483646 5 // [fp + 5] = [fp + -4] + (-1) (-1 as M31 -> 2147483646 (=-1 mod M31))
  24: 4 2147483642 0 6     // Arg 0 slot 0: [fp + 6] = [fp + -5] + 0
  25: 4 5 0 7              // Arg 1 slot 0: [fp + 7] = [fp + 5] + 0
  26: 10 9 14 _            // call power
  27: 2 2147483642 8 2147483644 // [fp + -3] = [fp + -5] op [fp + 8]
  28: 11 _ _ _             // return
factorial:
  29: 4 2147483643 0 0     // [fp + 0] = [fp + -4] + (-0) (-0 as M31 -> 0)
  30: 14 0 3 _             // if [fp + 0] != 0 jmp rel not_zero_2
  31: 9 1 0 _              // [fp + 0] = 1
  32: 13 2 _ _             // jump rel end_3
not_zero_2:
  33: 9 0 0 _              // [fp + 0] = 0
end_3:
  34: 14 0 2 _             // if [fp + 0] != 0 jmp rel factorial_1
  35: 13 3 _ _             // jump rel factorial_2
factorial_1:
  36: 9 1 2147483644 _     // Return value 0: [fp -3] = 1
  37: 11 _ _ _             // return
factorial_2:
  38: 4 2147483643 2147483646 4 // [fp + 4] = [fp + -4] + (-1) (-1 as M31 -> 2147483646 (=-1 mod M31))
  39: 10 6 29 _            // call factorial
  40: 2 2147483643 5 2147483644 // [fp + -3] = [fp + -4] op [fp + 5]
  41: 11 _ _ _             // return
