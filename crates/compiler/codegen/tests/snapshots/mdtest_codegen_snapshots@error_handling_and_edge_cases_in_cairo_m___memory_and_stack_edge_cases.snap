---
source: crates/compiler/codegen/tests/mdtest_snapshots.rs
assertion_line: 59
description: "Codegen snapshot for mdtest: Error Handling and Edge Cases in Cairo-M - Memory and Stack Edge Cases"
input_file: mdtest/05-edge-cases/01-error-handling.md
---
Source:
fn deep_recursion(n: u32, depth: u32) -> u32 {
    if (depth > 1000u32) {  // Prevent stack overflow
        return n;
    }

    if (n <= 1u32) {
        return 1;
    }

    return n + deep_recursion(n - 1, depth + 1);
}
============================================================
Generated CASM:
deep_recursion:
deep_recursion:
deep_recursion_0:
   0: 34 -6 1001 0 0       // [fp + 0] = u32([fp + -6], [fp + -5]) U32Greater u32(1001, 0) /* imm = 0x000003e9 */ (biased c' = 0x000003e9; gt = 1 - lt)
   1: 9 1 10 _             // [fp + 10] = 1
   2: 4 0 0 11             // [fp + 11] = [fp + 0] + 0
   3: 1 10 11 0            // [fp + 0] = 1 - [fp + 0]
   4: 14 0 2 _             // if [fp + 0] != 0 jmp rel deep_recursion_1
   5: 12 10 _ _            // jump abs deep_recursion_2
deep_recursion_1:
   6: 4 -8 0 -4            // Return value 0 slot 0: [fp -4] = [fp + -8] + 0
   7: 4 -7 0 -3            // Return value 0 slot 1: [fp -3] = [fp + -7] + 0
   8: 11 _ _ _             // return
deep_recursion_2:
   9: 34 -8 2 0 1          // [fp + 1] = u32([fp + -8], [fp + -7]) U32LessEqual u32(2, 0) /* imm = 0x00000002 */ (biased c' = 0x00000002)
  10: 14 1 2 _             // if [fp + 1] != 0 jmp rel deep_recursion_3
  11: 12 16 _ _            // jump abs deep_recursion_4
deep_recursion_3:
  12: 23 1 0 -4            // Return value 0: [fp -4, fp -4 + 1] = u32(1)
  13: 11 _ _ _             // return
deep_recursion_4:
  14: 19 -8 65535 65535 2  // u32([fp + 2], [fp + 3]) = u32([fp + -8], [fp + -7]) U32Sub u32(65535, 65535) /* imm = 0xffffffff */ (two's complement of 1 -> 4294967295)
  15: 19 -6 1 0 14         // u32([fp + 14], [fp + 15]) = u32([fp + -6], [fp + -5]) U32Add u32(1, 0) /* imm = 0x00000001 */
  16: 4 2 0 16             // Arg 0 slot 0: [fp + 16] = [fp + 2] + 0
  17: 4 3 0 17             // Arg 0 slot 1: [fp + 17] = [fp + 3] + 0
  18: 4 14 0 18            // Arg 1 slot 0: [fp + 18] = [fp + 14] + 0
  19: 4 15 0 19            // Arg 1 slot 1: [fp + 19] = [fp + 15] + 0
  20: 10 22 0 _            // call deep_recursion
  21: 15 -8 20 8           // u32([fp + 8], [fp + 9]) = u32([fp + -8], [fp + -7]) U32Add u32([fp + 20], [fp + 21])
  22: 4 8 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 8] + 0
  23: 4 9 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 9] + 0
  24: 11 _ _ _             // return
