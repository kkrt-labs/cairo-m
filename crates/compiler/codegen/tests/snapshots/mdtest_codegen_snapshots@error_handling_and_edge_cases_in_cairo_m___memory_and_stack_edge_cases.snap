---
source: crates/compiler/codegen/tests/mdtest_snapshots.rs
description: "Codegen snapshot for mdtest: Error Handling and Edge Cases in Cairo-M - Memory and Stack Edge Cases"
input_file: mdtest/05-edge-cases/01-error-handling.md
---
Source:
fn deep_recursion(n: u32, depth: u32) -> u32 {
    if (depth > 1000u32) {  // Prevent stack overflow
        return n;
    }

    if (n <= 1u32) {
        return 1;
    }

    return n + deep_recursion(n - 1, depth + 1);
}
============================================================
Generated CASM:
deep_recursion:
deep_recursion:
deep_recursion_0:
   0: 23 1000 0 11         // [fp + 11], [fp + 12] = u32(1000)
   1: 28 11 -6 0           // [fp + 0] = u32([fp + 11], [fp + 12]) U32Less u32([fp + -6], [fp + -5])
   2: 14 0 2 _             // if [fp + 0] != 0 jmp rel deep_recursion_1
   3: 12 7 _ _             // jump abs deep_recursion_2
deep_recursion_1:
   4: 4 -8 0 -4            // Return value 0 slot 0: [fp -4] = [fp + -8] + 0
   5: 4 -7 0 -3            // Return value 0 slot 1: [fp -3] = [fp + -7] + 0
   6: 11 _ _ _             // return
deep_recursion_2:
   7: 23 1 0 13            // [fp + 13], [fp + 14] = u32(1)
   8: 28 13 -8 1           // [fp + 1] = u32([fp + 13], [fp + 14]) U32Less u32([fp + -8], [fp + -7])
   9: 14 1 3 _             // if [fp + 1] != 0 jmp rel not_zero_0
  10: 9 1 2 _              // [fp + 2] = 1
  11: 12 13 _ _            // jump abs not_end_1
not_zero_0:
  12: 9 0 2 _              // [fp + 2] = 0
not_end_1:
  13: 14 2 2 _             // if [fp + 2] != 0 jmp rel deep_recursion_3
  14: 12 17 _ _            // jump abs deep_recursion_4
deep_recursion_3:
  15: 23 1 0 -4            // Return value 0: [fp -4, fp -4 + 1] = u32(1)
  16: 11 _ _ _             // return
deep_recursion_4:
  17: 19 -8 65535 65535 3  // u32([fp + 3], [fp + 4]) = u32([fp + -8], [fp + -7]) U32Sub u32(65535, 65535) /* imm = 0xffffffff */ (two's complement of 1 -> 4294967295)
  18: 19 -6 1 0 17         // u32([fp + 17], [fp + 18]) = u32([fp + -6], [fp + -5]) U32Add u32(1, 0) /* imm = 0x00000001 */
  19: 4 3 0 19             // Arg 0 slot 0: [fp + 19] = [fp + 3] + 0
  20: 4 4 0 20             // Arg 0 slot 1: [fp + 20] = [fp + 4] + 0
  21: 4 17 0 21            // Arg 1 slot 0: [fp + 21] = [fp + 17] + 0
  22: 4 18 0 22            // Arg 1 slot 1: [fp + 22] = [fp + 18] + 0
  23: 10 25 0 _            // call deep_recursion
  24: 15 -8 23 9           // u32([fp + 9], [fp + 10]) = u32([fp + -8], [fp + -7]) U32Add u32([fp + 23], [fp + 24])
  25: 4 9 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 9] + 0
  26: 4 10 0 -3            // Return value 0 slot 1: [fp -3] = [fp + 10] + 0
  27: 11 _ _ _             // return
