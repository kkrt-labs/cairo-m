---
source: crates/compiler/codegen/tests/mdtest_snapshots.rs
description: "Codegen snapshot for mdtest: Complex Expressions in Cairo-M - Compound Expressions"
input_file: mdtest/01-basics/06-expressions.md
---
Source:
fn test_compound_expressions() -> u32 {
    let x: u32 = 8;
    let y: u32 = 3;
    let z: u32 = 12;

    // Complex arithmetic with precedence
    let expr1 = x * y + z / 4u32;                    // 8 * 3 + 12 / 4 = 24 + 3 = 27

    // Nested parentheses
    let expr2 = (x + y) * (z - y * 2u32);            // (8 + 3) * (12 - 3 * 2) = 11 * 6 = 66

    // Mixed arithmetic and comparison
    let expr3 = (x > y) && ((z + x) < 25u32);        // (8 > 3) && ((12 + 8) < 25) = 1 && 1 = 1

    let res = expr1 + expr2;
    if expr3 {
        res = res + 1u32;
    }
    return res;
}
============================================================
Generated CASM:
test_compound_expressions:
test_compound_expressions:
test_compound_expressions_0:
   0: 23 8 0 0             // u32([fp + 0], [fp + 1]) = u32(8)
   1: 23 3 0 2             // u32([fp + 2], [fp + 3]) = u32(3)
   2: 23 12 0 4            // u32([fp + 4], [fp + 5]) = u32(12)
   3: 17 0 2 6             // u32([fp + 6], [fp + 7]) = u32([fp + 0], [fp + 1]) U32Mul u32([fp + 2], [fp + 3])
   4: 22 4 4 0 8 31        // u32([fp + 8], [fp + 9]); u32([fp + 31], [fp + 32]) = u32([fp + 4], [fp + 5]) / u32(4, 0)
   5: 15 6 8 10            // u32([fp + 10], [fp + 11]) = u32([fp + 6], [fp + 7]) U32Add u32([fp + 8], [fp + 9])
   6: 15 0 2 12            // u32([fp + 12], [fp + 13]) = u32([fp + 0], [fp + 1]) U32Add u32([fp + 2], [fp + 3])
   7: 21 2 2 0 14          // u32([fp + 14], [fp + 15]) = u32([fp + 2], [fp + 3]) U32Mul u32(2, 0) /* imm = 0x00000002 */
   8: 16 4 14 16           // u32([fp + 16], [fp + 17]) = u32([fp + 4], [fp + 5]) U32Sub u32([fp + 14], [fp + 15])
   9: 17 12 16 18          // u32([fp + 18], [fp + 19]) = u32([fp + 12], [fp + 13]) U32Mul u32([fp + 16], [fp + 17])
  10: 28 2 0 20            // [fp + 20] = u32([fp + 2], [fp + 3]) U32Less u32([fp + 0], [fp + 1])
  11: 15 4 0 21            // u32([fp + 21], [fp + 22]) = u32([fp + 4], [fp + 5]) U32Add u32([fp + 0], [fp + 1])
  12: 34 21 25 0 23        // [fp + 23] = u32([fp + 21], [fp + 22]) U32Less u32(25, 0) /* imm = 0x00000019 */
  13: 9 0 24 _             // [fp + 24] = 0
  14: 14 20 2 _            // if [fp + 20] != 0 jmp rel and_check_right_0
  15: 13 4 _ _             // jump rel and_end_2
and_check_right_0:
  16: 14 23 2 _            // if [fp + 23] != 0 jmp rel and_true_1
  17: 13 2 _ _             // jump rel and_end_2
and_true_1:
  18: 9 1 24 _             // [fp + 24] = 1
and_end_2:
  19: 15 10 18 25          // u32([fp + 25], [fp + 26]) = u32([fp + 10], [fp + 11]) U32Add u32([fp + 18], [fp + 19])
  20: 19 25 0 0 27         // u32([fp + 27], [fp + 28]) = u32([fp + 25], [fp + 26]) + u32(0, 0)
  21: 14 24 2 _            // if [fp + 24] != 0 jmp rel test_compound_expressions_1
  22: 13 8 _ _             // jump rel test_compound_expressions_3
test_compound_expressions_1:
  23: 19 25 1 0 29         // u32([fp + 29], [fp + 30]) = u32([fp + 25], [fp + 26]) U32Add u32(1, 0) /* imm = 0x00000001 */
  24: 19 29 0 0 27         // u32([fp + 27], [fp + 28]) = u32([fp + 29], [fp + 30]) + u32(0, 0)
test_compound_expressions_2:
  25: 4 27 0 2147483643    // Return value 0 slot 0: [fp -4] = [fp + 27] + 0
  26: 4 28 0 2147483644    // Return value 0 slot 1: [fp -3] = [fp + 28] + 0
  27: 11 _ _ _             // return
test_compound_expressions_3:
  28: 13 2147483644 _ _    // jump rel test_compound_expressions_2
