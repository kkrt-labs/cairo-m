---
source: crates/compiler/codegen/tests/codegen_tests.rs
expression: snapshot_content
---
---
source: crates/compiler/codegen/tests/codegen_tests.rs
expression: codegen_output
---
Fixture: u32_ops.cm
============================================================
Source code:
// Test U32 arithmetic operations
fn define_u32() -> u32 {
    let a: u32 = 1;
    return 42 + a;
}

fn add_u32(a: u32, b: u32) -> u32 {
    return a + b;
}

fn sub_u32(a: u32, b: u32) -> u32 {
    return a - b;
}

fn mul_u32(a: u32, b: u32) -> u32 {
    return a * b;
}

fn div_u32(a: u32, b: u32) -> u32 {
    return a / b;
}

// Test mixed operations
fn complex_u32_expr(x: u32, y: u32, z: u32) -> u32 {
    let temp = x * y;
    let result = temp + z;
    return result;
}

============================================================
Generated CASM:
define_u32:
define_u32:
define_u32_0:
   0: 23 1 0 0             // [fp + 0, fp + 1] = u32(1)
   1: 19 0 42 1            // u32([fp + 1], [fp + 1 + 1]) = u32([fp + 0], [fp + 0 + 1]) op u32(42, 0)
   2: 4 1 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 1] + 0
   3: 4 2 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 2] + 0
   4: 11 _ _ _             // return
add_u32:
add_u32_0:
   5: 15 -8 -6 0           // u32([fp + 0], [fp + 0 + 1]) = u32([fp + -8], [fp + -8 + 1]) op u32([fp + -6], [fp + -6 + 1])
add_u32:
   6: 4 0 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 0] + 0
   7: 4 1 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 1] + 0
   8: 11 _ _ _             // return
sub_u32:
sub_u32_0:
   9: 16 -8 -6 0           // u32([fp + 0], [fp + 0 + 1]) = u32([fp + -8], [fp + -8 + 1]) op u32([fp + -6], [fp + -6 + 1])
sub_u32:
  10: 4 0 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 0] + 0
  11: 4 1 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 1] + 0
  12: 11 _ _ _             // return
mul_u32:
mul_u32_0:
  13: 17 -8 -6 0           // u32([fp + 0], [fp + 0 + 1]) = u32([fp + -8], [fp + -8 + 1]) op u32([fp + -6], [fp + -6 + 1])
mul_u32:
  14: 4 0 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 0] + 0
  15: 4 1 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 1] + 0
  16: 11 _ _ _             // return
div_u32:
div_u32_0:
  17: 18 -8 -6 0           // u32([fp + 0], [fp + 0 + 1]) = u32([fp + -8], [fp + -8 + 1]) op u32([fp + -6], [fp + -6 + 1])
div_u32:
  18: 4 0 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 0] + 0
  19: 4 1 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 1] + 0
  20: 11 _ _ _             // return
complex_u32_expr:
complex_u32_expr_0:
  21: 17 -10 -8 0          // u32([fp + 0], [fp + 0 + 1]) = u32([fp + -10], [fp + -10 + 1]) op u32([fp + -8], [fp + -8 + 1])
complex_u32_expr:
  22: 15 0 -6 2            // u32([fp + 2], [fp + 2 + 1]) = u32([fp + 0], [fp + 0 + 1]) op u32([fp + -6], [fp + -6 + 1])
  23: 4 2 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 2] + 0
  24: 4 3 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 3] + 0
  25: 11 _ _ _             // return
