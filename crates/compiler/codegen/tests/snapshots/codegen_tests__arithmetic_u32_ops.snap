---
source: crates/compiler/codegen/tests/codegen_tests.rs
expression: snapshot_content
---
---
source: crates/compiler/codegen/tests/codegen_tests.rs
expression: codegen_output
---
Fixture: u32_ops.cm
============================================================
Source code:
// Test U32 arithmetic operations
fn define_u32() -> u32 {
    let a: u32 = 1;
    return 42 + a;
}

fn add_u32(a: u32, b: u32) -> u32 {
    return a + b;
}

fn sub_u32(a: u32, b: u32) -> u32 {
    return a - b;
}

fn mul_u32(a: u32, b: u32) -> u32 {
    return a * b;
}

fn div_u32(a: u32, b: u32) -> u32 {
    return a / b;
}

// Test mixed operations
fn complex_u32_expr(x: u32, y: u32, z: u32) -> u32 {
    let temp = x * y;
    let result = temp + z;
    return result;
}

============================================================
Generated CASM:
define_u32:
define_u32:
define_u32_0:
   0: 23 1 0 0             // [fp + 0, fp + 0 + 1] = u32(1)
   4: 19 0 42 2            // u32([fp + 2], [fp + 2 + 1]) = u32([fp + 0], [fp + 0 + 1]) op u32(42, 0)
   9: 4 2 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 2] + 0
  13: 4 3 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 3] + 0
  17: 11 _ _ _             // return
add_u32:
add_u32_0:
  18: 15 -8 -6 0           // u32([fp + 0], [fp + 0 + 1]) = u32([fp + -8], [fp + -8 + 1]) op u32([fp + -6], [fp + -6 + 1])
  22: 4 0 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 0] + 0
  26: 4 1 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 1] + 0
  30: 11 _ _ _             // return
sub_u32:
sub_u32_0:
  31: 16 -8 -6 0           // u32([fp + 0], [fp + 0 + 1]) = u32([fp + -8], [fp + -8 + 1]) op u32([fp + -6], [fp + -6 + 1])
  35: 4 0 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 0] + 0
  39: 4 1 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 1] + 0
  43: 11 _ _ _             // return
mul_u32:
mul_u32_0:
  44: 17 -8 -6 0           // u32([fp + 0], [fp + 0 + 1]) = u32([fp + -8], [fp + -8 + 1]) op u32([fp + -6], [fp + -6 + 1])
  48: 4 0 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 0] + 0
  52: 4 1 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 1] + 0
  56: 11 _ _ _             // return
div_u32:
div_u32_0:
  57: 18 -8 -6 0           // u32([fp + 0], [fp + 0 + 1]) = u32([fp + -8], [fp + -8 + 1]) op u32([fp + -6], [fp + -6 + 1])
add_u32:
  61: 4 0 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 0] + 0
  65: 4 1 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 1] + 0
  69: 11 _ _ _             // return
complex_u32_expr:
complex_u32_expr_0:
  70: 17 -10 -8 0          // u32([fp + 0], [fp + 0 + 1]) = u32([fp + -10], [fp + -10 + 1]) op u32([fp + -8], [fp + -8 + 1])
  74: 15 0 -6 2            // u32([fp + 2], [fp + 2 + 1]) = u32([fp + 0], [fp + 0 + 1]) op u32([fp + -6], [fp + -6 + 1])
  78: 4 2 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 2] + 0
  82: 4 3 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 3] + 0
  86: 11 _ _ _             // return
