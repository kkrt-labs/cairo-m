---
source: crates/compiler/codegen/tests/codegen_tests.rs
expression: snapshot_content
---
---
source: crates/compiler/codegen/tests/codegen_tests.rs
expression: codegen_output
---
Fixture: random_instructions.cm
============================================================
Source code:
func main(){
    let x = 3;
    let y = 13;
    let even_number = 16;
    let eq = x == y;
    let mut_val = 1;
    if (eq) {
        mut_val = mut_val + eq + 1;
    }
    mut_val = mut_val * mut_val;
    mut_val = mut_val + (even_number / 2);

    let eq2 = (x == x);

    let compound1 = x || (y == 3) + 2;
    let compound2 = eq != 2 && 3;

    return mut_val + eq2 + foo() + 32;
}

func foo() -> felt {
    return 32;
}

============================================================
Generated CASM:
main:
   0: 6 3 _ 0              // Store immediate: [fp + 0] = 3
   1: 6 13 _ 1             // Store immediate: [fp + 1] = 13
   2: 6 16 _ 2             // Store immediate: [fp + 2] = 16
   3: 2 0 1 4              // [fp + 4] = [fp + 0] op [fp + 1]
   4: 31 4 3 _             // if temp != 0, jump to not_zero
   5: 6 1 _ 3              // Set [fp + 3] to 1
   6: 20 8 _ _             // jump to end
not_zero_0:
   7: 6 0 _ 3              // Set [fp + 3] to 0
end_1:
   8: 4 3 _ 5              // Store: [fp + 5] = [fp + 3]
   9: 6 1 _ 6              // Store immediate: [fp + 6] = 1
  10: 31 5 2 _             // if [fp + 5] != 0 jmp rel main_1
  11: 20 15 _ _            // jump abs main_2
main_1:
  12: 0 6 5 7              // [fp + 7] = [fp + 6] op [fp + 5]
  13: 1 7 1 8              // [fp + 8] = [fp + 7] op 1
  14: 4 8 _ 6              // Store: [fp + 6] = [fp + 8]
main_2:
  15: 7 6 6 9              // [fp + 9] = [fp + 6] op [fp + 6]
  16: 4 9 _ 6              // Store: [fp + 6] = [fp + 9]
  17: 10 2 2 10            // [fp + 10] = [fp + 2] op 2
  18: 0 6 10 11            // [fp + 11] = [fp + 6] op [fp + 10]
  19: 4 11 _ 6             // Store: [fp + 6] = [fp + 11]
  20: 2 0 0 4              // [fp + 4] = [fp + 0] op [fp + 0]
  21: 31 4 3 _             // if temp != 0, jump to not_zero
  22: 6 1 _ 12             // Set [fp + 12] to 1
  23: 20 25 _ _            // jump to end
not_zero_2:
  24: 6 0 _ 12             // Set [fp + 12] to 0
end_3:
  25: 4 12 _ 13            // Store: [fp + 13] = [fp + 12]
  26: 3 1 3 4              // [fp + 4] = [fp + 1] op 3
  27: 31 4 3 _             // if temp != 0, jump to not_zero
  28: 6 1 _ 14             // Set [fp + 14] to 1
  29: 20 31 _ _            // jump to end
not_zero_4:
  30: 6 0 _ 14             // Set [fp + 14] to 0
end_5:
  31: 1 14 2 15            // [fp + 15] = [fp + 14] op 2
  32: 6 0 _ 16             // Initialize OR result to 0
  33: 31 0 3 _             // if left != 0, set result to 1
  34: 31 15 2 _            // if right != 0, set result to 1
  35: 20 37 _ _            // Both operands were 0, keep result as 0
or_true_6:
  36: 6 1 _ 16             // Set OR result to 1
or_end_7:
  37: 3 5 2 4              // [fp + 4] = [fp + 5] op 2
  38: 31 4 3 _             // if temp != 0, jump to set result to 1
  39: 6 0 _ 17             // Set NEQ result to 0
  40: 20 42 _ _            // jump to end
neq_non_zero_8:
  41: 6 1 _ 17             // Set NEQ result to 1
neq_end_9:
  42: 8 17 3 4             // [fp + 4] = [fp + 17] op 3
  43: 31 4 3 _             // if temp != 0, jump to set result to 1
  44: 6 0 _ 18             // Set AND result to 0
  45: 20 47 _ _            // jump to end
and_non_zero_10:
  46: 6 1 _ 18             // Set AND result to 1
and_end_11:
  47: 0 6 13 19            // [fp + 19] = [fp + 6] op [fp + 13]
  48: 12 21 52 _           // call foo
  49: 0 19 20 22           // [fp + 22] = [fp + 19] op [fp + 20]
  50: 1 22 32 -3           // [fp + -3] = [fp + 22] op 32
  51: 15 _ _ _             // return
foo:
  52: 6 32 _ -3            // Return value: [fp - 3] = 32
  53: 15 _ _ _             // return
