---
source: crates/compiler/codegen/tests/codegen_tests.rs
expression: snapshot_content
---
---
source: crates/compiler/codegen/tests/codegen_tests.rs
expression: codegen_output
---
Fixture: random_instructions.cm
============================================================
Source code:
func main(){
    let x = 3;
    let y = 13;
    let even_number = 16;
    let eq = x == y;
    let mut_val = 1;
    if (eq) {
        mut_val = mut_val + eq + 1;
    }
    mut_val = mut_val * mut_val;
    mut_val = mut_val + (even_number / 2);

    let eq2 = (x == 3);

    let compound1 = x || (y == 3) + 2;
    let compound2 = eq != 2 && 3;

    let (a, b) = foo();
    return mut_val + eq2 + a + bar() + b + compound1 + compound2;
}

func foo() -> (felt, felt) {
    return (32, 62);
}

func bar() -> felt {
    return 123;
}

============================================================
Generated CASM:
main:
   0: 6 3 _ 0              // Store immediate: [fp + 0] = 3
   1: 6 13 _ 1             // Store immediate: [fp + 1] = 13
   2: 6 16 _ 2             // Store immediate: [fp + 2] = 16
   3: 2 0 1 3              // [fp + 3] = [fp + 0] op [fp + 1]
   4: 15 3 3 _             // if [fp + 3] != 0, jump to not_zero_0
   5: 6 1 _ 3              // [fp + 3] = 1
   6: 13 8 _ _             // jump to end_1
not_zero_0:
   7: 6 0 _ 3              // [fp + 3] = 0
end_1:
   8: 2 0 1 4              // [fp + 4] = [fp + 0] op [fp + 1]
   9: 15 4 3 _             // if [fp + 4] != 0, jump to not_zero_2
  10: 6 1 _ 4              // [fp + 4] = 1
  11: 13 13 _ _            // jump to end_3
not_zero_2:
  12: 6 0 _ 4              // [fp + 4] = 0
end_3:
  13: 4 4 _ 5              // Store: [fp + 5] = [fp + 4]
  14: 6 1 _ 6              // Store immediate: [fp + 6] = 1
  15: 15 5 2 _             // if [fp + 5] != 0 jmp rel main_1
  16: 13 19 _ _            // jump abs main_2
main_1:
  17: 0 6 5 7              // [fp + 7] = [fp + 6] op [fp + 5]
  18: 1 7 1 6              // [fp + 6] = [fp + 7] op 1
main_2:
  19: 7 6 6 6              // [fp + 6] = [fp + 6] op [fp + 6]
  20: 10 2 2 8             // [fp + 8] = [fp + 2] op 2
  21: 0 6 8 6              // [fp + 6] = [fp + 6] op [fp + 8]
  22: 3 0 3 9              // [fp + 9] = [fp + 0] op 3
  23: 15 9 3 _             // if [fp + 9] != 0, jump to not_zero_4
  24: 6 1 _ 9              // [fp + 9] = 1
  25: 13 27 _ _            // jump to end_5
not_zero_4:
  26: 6 0 _ 9              // [fp + 9] = 0
end_5:
  27: 3 0 3 10             // [fp + 10] = [fp + 0] op 3
  28: 15 10 3 _            // if [fp + 10] != 0, jump to not_zero_6
  29: 6 1 _ 10             // [fp + 10] = 1
  30: 13 32 _ _            // jump to end_7
not_zero_6:
  31: 6 0 _ 10             // [fp + 10] = 0
end_7:
  32: 4 10 _ 11            // Store: [fp + 11] = [fp + 10]
  33: 3 1 3 12             // [fp + 12] = [fp + 1] op 3
  34: 15 12 3 _            // if [fp + 12] != 0, jump to not_zero_8
  35: 6 1 _ 12             // [fp + 12] = 1
  36: 13 38 _ _            // jump to end_9
not_zero_8:
  37: 6 0 _ 12             // [fp + 12] = 0
end_9:
  38: 1 12 2 13            // [fp + 13] = [fp + 12] op 2
  39: 6 0 _ 14             // Initialize OR result to 0
  40: 15 0 3 _             // if [fp + 0] != 0, jump to or_true_10
  41: 15 13 2 _            // if [fp + 13] != 0, jump to or_true_10
  42: 13 44 _ _            // jump to or_end_11
or_true_10:
  43: 6 1 _ 14             // [fp + 14] = 1
or_end_11:
  44: 3 1 3 15             // [fp + 15] = [fp + 1] op 3
  45: 15 15 3 _            // if [fp + 15] != 0, jump to not_zero_12
  46: 6 1 _ 15             // [fp + 15] = 1
  47: 13 49 _ _            // jump to end_13
not_zero_12:
  48: 6 0 _ 15             // [fp + 15] = 0
end_13:
  49: 1 15 2 16            // [fp + 16] = [fp + 15] op 2
  50: 6 0 _ 17             // Initialize OR result to 0
  51: 15 0 3 _             // if [fp + 0] != 0, jump to or_true_14
  52: 15 16 2 _            // if [fp + 16] != 0, jump to or_true_14
  53: 13 55 _ _            // jump to or_end_15
or_true_14:
  54: 6 1 _ 17             // [fp + 17] = 1
or_end_15:
  55: 4 17 _ 18            // Store: [fp + 18] = [fp + 17]
  56: 3 5 2 19             // [fp + 19] = [fp + 5] op 2
  57: 15 19 3 _            // if [fp + 19] != 0, jump to neq_non_zero_16
  58: 6 0 _ 19             // [fp + 19] = 0
  59: 13 61 _ _            // jump to neq_end_17
neq_non_zero_16:
  60: 6 1 _ 19             // [fp + 19] = 1
neq_end_17:
  61: 8 19 3 20            // [fp + 20] = [fp + 19] op 3
  62: 15 20 3 _            // if [fp + 20] != 0, jump to and_non_zero_18
  63: 6 0 _ 20             // [fp + 20] = 0
  64: 13 66 _ _            // jump to and_end_19
and_non_zero_18:
  65: 6 1 _ 20             // [fp + 20] = 1
and_end_19:
  66: 3 5 2 21             // [fp + 21] = [fp + 5] op 2
  67: 15 21 3 _            // if [fp + 21] != 0, jump to neq_non_zero_20
  68: 6 0 _ 21             // [fp + 21] = 0
  69: 13 71 _ _            // jump to neq_end_21
neq_non_zero_20:
  70: 6 1 _ 21             // [fp + 21] = 1
neq_end_21:
  71: 8 21 3 22            // [fp + 22] = [fp + 21] op 3
  72: 15 22 3 _            // if [fp + 22] != 0, jump to and_non_zero_22
  73: 6 0 _ 22             // [fp + 22] = 0
  74: 13 76 _ _            // jump to and_end_23
and_non_zero_22:
  75: 6 1 _ 22             // [fp + 22] = 1
and_end_23:
  76: 4 22 _ 23            // Store: [fp + 23] = [fp + 22]
  77: 11 26 86 _           // call foo
  78: 0 6 11 28            // [fp + 28] = [fp + 6] op [fp + 11]
  79: 0 28 24 29           // [fp + 29] = [fp + 28] op [fp + 24]
  80: 11 31 89 _           // call bar
  81: 0 29 30 32           // [fp + 32] = [fp + 29] op [fp + 30]
  82: 0 32 25 33           // [fp + 33] = [fp + 32] op [fp + 25]
  83: 0 33 18 34           // [fp + 34] = [fp + 33] op [fp + 18]
  84: 0 34 23 -3           // [fp + -3] = [fp + 34] op [fp + 23]
  85: 12 _ _ _             // return
foo:
  86: 6 32 _ -4            // Return value 0: [fp -4] = 32
  87: 6 62 _ -3            // Return value 1: [fp -3] = 62
  88: 12 _ _ _             // return
bar:
  89: 6 123 _ -3           // Return value 0: [fp -3] = 123
  90: 12 _ _ _             // return
