---
source: crates/compiler/codegen/tests/codegen_tests.rs
expression: snapshot_content
---
---
source: crates/compiler/codegen/tests/codegen_tests.rs
expression: codegen_output
---
Fixture: random_instructions.cm
============================================================
Source code:
fn main() -> felt {
    let x = 3;
    let y = 13;
    let even_number = 16;
    let eq = x == y;
    let mut_val = 1;
    let eq_felt = 0;
    if (eq){
        eq_felt = 1;
        mut_val = mut_val + eq_felt + 1;
    }
    mut_val = mut_val * mut_val;
    mut_val = mut_val + (even_number / 2);

    let eq2 = (x == 3);
    let eq2_felt = 0;
    if (eq2){
        eq2_felt = 1;
    }

    let tempvar = 0;
    if (y == 3) {
        tempvar = 1;
    }
    let compound1 = (x != 0) || ((tempvar) + 2 != 0);
    let compound1_felt = 0;
    if (compound1){
        compound1_felt = 1;
    }
    let compound2 = (eq_felt != 2) && (3 != 0);

    let compound2_felt = 0;
    if (compound2){
        compound2_felt = 1;
    }

    for (let i = 0; i != 3; i = i + 1) {
        mut_val = mut_val + i;
    }

    let (a, b) = foo();
    return mut_val + eq2_felt + a + bar() + b + compound1_felt + compound2_felt;
}

fn foo() -> (felt, felt) {
    return (32, 62);
}

fn bar() -> felt {
    return 123;
}

============================================================
Generated CASM:
main:
   0: 9 3 0 _              // [fp + 0] = 3
   3: 9 13 1 _             // [fp + 1] = 13
   6: 9 16 2 _             // [fp + 2] = 16
   9: 1 0 1 3              // [fp + 3] = [fp + 0] op [fp + 1]
  13: 14 3 8 _             // if [fp + 3] != 0, jump to not_zero_0
  16: 9 1 3 _              // [fp + 3] = 1
  19: 12 24 _ _            // jump to end_1
not_zero_0:
  21: 9 0 3 _              // [fp + 3] = 0
end_1:
  24: 9 1 4 _              // Store immediate: [fp + 4] = 1
  27: 14 3 5 _             // if [fp + 3] != 0 jmp rel main_1
  30: 12 40 _ _            // jump abs main_2
main_1:
  32: 0 4 3 5              // [fp + 5] = [fp + 4] op [fp + 3]
  36: 4 5 1 4              // [fp + 4] = [fp + 5] op 1
main_2:
  40: 4 4 0 28             // [fp + 28] = [fp + 4] + 0
  44: 4 4 0 29             // [fp + 29] = [fp + 4] + 0
  48: 2 28 29 4            // [fp + 4] = [fp + 28] op [fp + 29]
  52: 7 2 2 6              // [fp + 6] = [fp + 2] op 2
  56: 4 4 0 28             // [fp + 28] = [fp + 4] + 0
  60: 0 28 6 4             // [fp + 4] = [fp + 28] op [fp + 6]
  64: 5 0 3 7              // [fp + 7] = [fp + 0] op 3
  68: 14 7 8 _             // if [fp + 7] != 0, jump to not_zero_2
  71: 9 1 7 _              // [fp + 7] = 1
  74: 12 79 _ _            // jump to end_3
not_zero_2:
  76: 9 0 7 _              // [fp + 7] = 0
end_3:
  79: 5 1 3 8              // [fp + 8] = [fp + 1] op 3
  83: 14 8 8 _             // if [fp + 8] != 0, jump to not_zero_4
  86: 9 1 8 _              // [fp + 8] = 1
  89: 12 94 _ _            // jump to end_5
not_zero_4:
  91: 9 0 8 _              // [fp + 8] = 0
end_5:
  94: 4 8 2 9              // [fp + 9] = [fp + 8] op 2
  98: 9 0 10 _             // Initialize OR result to 0
 101: 14 0 8 _             // if [fp + 0] != 0, jump to or_true_6
 104: 14 9 5 _             // if [fp + 9] != 0, jump to or_true_6
 107: 12 112 _ _           // jump to or_end_7
or_true_6:
 109: 9 1 10 _             // [fp + 10] = 1
or_end_7:
 112: 5 3 2 11             // [fp + 11] = [fp + 3] op 2
 116: 14 11 8 _            // if [fp + 11] != 0, jump to neq_non_zero_8
 119: 9 0 11 _             // [fp + 11] = 0
 122: 12 127 _ _           // jump to neq_end_9
neq_non_zero_8:
 124: 9 1 11 _             // [fp + 11] = 1
neq_end_9:
 127: 6 11 3 12            // [fp + 12] = [fp + 11] op 3
 131: 14 12 8 _            // if [fp + 12] != 0, jump to and_non_zero_10
 134: 9 0 12 _             // [fp + 12] = 0
 137: 12 142 _ _           // jump to and_end_11
and_non_zero_10:
 139: 9 1 12 _             // [fp + 12] = 1
and_end_11:
 142: 10 24 173 _          // call foo
 145: 0 4 7 15             // [fp + 15] = [fp + 4] op [fp + 7]
 149: 0 15 22 16           // [fp + 16] = [fp + 15] op [fp + 22]
 153: 10 27 180 _          // call bar
 156: 0 16 26 18           // [fp + 18] = [fp + 16] op [fp + 26]
 160: 0 18 23 19           // [fp + 19] = [fp + 18] op [fp + 23]
 164: 0 19 10 20           // [fp + 20] = [fp + 19] op [fp + 10]
 168: 0 20 12 -3           // [fp + -3] = [fp + 20] op [fp + 12]
 172: 11 _ _ _             // return
foo:
 173: 9 32 -4 _            // Return value 0: [fp -4] = 32
 176: 9 62 -3 _            // Return value 1: [fp -3] = 62
 179: 11 _ _ _             // return
bar:
 180: 9 123 -3 _           // Return value 0: [fp -3] = 123
 183: 11 _ _ _             // return
