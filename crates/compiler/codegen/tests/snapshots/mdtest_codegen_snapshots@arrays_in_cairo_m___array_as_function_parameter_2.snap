---
source: crates/compiler/codegen/tests/mdtest_snapshots.rs
description: "Codegen snapshot for mdtest: Arrays in Cairo-M - Array as Function Parameter 2"
input_file: mdtest/01-basics/05-arrays.md
---
Source:
fn use_array_parameter() -> u32 {
    let my_array: [u32; 3] = [1, 2, 3];
    return process_array(my_array, 3felt);
}

fn process_array(arr: [u32; 3], size: felt) -> u32 {
    let sum: u32 = 0;
    let i = 0;
    loop {
        if i == size {
            break;
        }
        sum = sum + arr[i];
        arr[i] = 0;
        i = i + 1;
    }
    return sum;
}
============================================================
Generated CASM:
use_array_parameter:
use_array_parameter:
use_array_parameter_0:
   0: 23 1 0 3             // [fp + 3], [fp + 4] = u32(1)
   1: 23 2 0 5             // [fp + 5], [fp + 6] = u32(2)
   2: 23 3 0 7             // [fp + 7], [fp + 8] = u32(3)
   3: 43 3 0 _             // [fp + 0] = fp + 3
   4: 4 0 0 9              // Arg 0 slot 0: [fp + 9] = [fp + 0] + 0
   5: 9 3 10 _             // Arg 1: [fp + 10] = 3
   6: 10 13 10 _           // call process_array
   7: 4 11 0 2147483643    // Return value 0 slot 0: [fp -4] = [fp + 11] + 0
   8: 4 12 0 2147483644    // Return value 0 slot 1: [fp -3] = [fp + 12] + 0
   9: 11 _ _ _             // return
process_array:
process_array:
process_array_0:
  10: 23 0 0 0             // u32([fp + 0], [fp + 1]) = u32(0)
  11: 9 0 2 _              // [fp + 2] = 0
  12: 4 2 0 3              // [fp + 3] = [fp + 2] + 0
  13: 4 2147483641 0 4     // [fp + 4] = [fp + -6] + 0 (array pointer)
  14: 19 0 0 0 5           // u32([fp + 5], [fp + 6]) = u32([fp + 0], [fp + 1]) + u32(0, 0)
process_array_1:
  15: 1 3 2147483642 13    // [fp + 13] = [fp + 3] op [fp + -5]
  16: 14 13 6 _            // if [fp + 13] != 0 jmp rel process_array_4
  17: 12 22 _ _            // jump abs process_array_3
process_array_2:
  18: 4 5 0 2147483643     // Return value 0 slot 0: [fp -4] = [fp + 5] + 0
  19: 4 6 0 2147483644     // Return value 0 slot 1: [fp -3] = [fp + 6] + 0
  20: 11 _ _ _             // return
process_array_3:
  21: 12 19 _ _            // jump abs process_array_2
process_array_4:
  22: 6 3 2 14             // [fp + 14] = [fp + 3] * 2 - Scale index by element size
  23: 42 4 14 7            // [fp + 7] = [[fp + 4] + [fp + 14]]
  24: 4 14 1 15            // [fp + 15] = [fp + 14] + 1 (offset for slot 1)
  25: 42 4 15 8            // [fp + 8] = [[fp + 4] + [fp + 15]] (slot 1)
  26: 15 5 7 9             // u32([fp + 9], [fp + 10]) = u32([fp + 5], [fp + 6]) U32Add u32([fp + 7], [fp + 8])
  27: 6 3 2 16             // [fp + 16] = [fp + 3] * 2 - Scale index by element size
  28: 4 4 0 11             // [fp + 11] = [fp + 4] + 0 (copy array pointer)
  29: 23 0 0 17            // [fp + 17], [fp + 18] = u32(0)
  30: 45 4 16 17           // [[fp + 4] + [fp + 16]] = [fp + 17] (u32 slot 0)
  31: 4 16 1 19            // [fp + 19] = [fp + 16] + 1 (adjust for slot 1)
  32: 45 4 19 18           // [[fp + 4] + [fp + 19]] = [fp + 18] (u32 slot 1)
  33: 4 3 1 12             // [fp + 12] = [fp + 3] + 1
  34: 4 12 0 3             // [fp + 3] = [fp + 12] + 0
  35: 4 11 0 4             // [fp + 4] = [fp + 11] + 0 (array pointer)
  36: 19 9 0 0 5           // u32([fp + 5], [fp + 6]) = u32([fp + 9], [fp + 10]) + u32(0, 0)
  37: 12 16 _ _            // jump abs process_array_1
