---
source: crates/compiler/codegen/tests/mdtest_snapshots.rs
description: "Codegen snapshot for mdtest: Arrays in Cairo-M - Array as Function Parameter 2"
input_file: mdtest/01-basics/05-arrays.md
---
Source:
fn use_array_parameter() -> u32 {
    let my_array: [u32; 3] = [1, 2, 3];
    return process_array(my_array, 3felt);
}

fn process_array(arr: [u32; 3], size: felt) -> u32 {
    let sum: u32 = 0;
    let i = 0;
    loop {
        if i == size {
            break;
        }
        sum = sum + arr[i];
        arr[i] = 0;
        i = i + 1;
    }
    return sum;
}
============================================================
Generated CASM:
use_array_parameter:
use_array_parameter:
use_array_parameter_0:
   0: 23 1 0 3             // [fp + 3], [fp + 4] = u32(1)
   1: 23 2 0 5             // [fp + 5], [fp + 6] = u32(2)
   2: 23 3 0 7             // [fp + 7], [fp + 8] = u32(3)
   3: 43 3 0 _             // [fp + 0] = fp + 3
   4: 4 0 0 9              // Arg 0 slot 0: [fp + 9] = [fp + 0] + 0
   5: 9 3 10 _             // Arg 1: [fp + 10] = 3
   6: 10 13 10 _           // call process_array
   7: 4 11 0 2147483643    // Return value 0 slot 0: [fp -4] = [fp + 11] + 0
   8: 4 12 0 2147483644    // Return value 0 slot 1: [fp -3] = [fp + 12] + 0
   9: 11 _ _ _             // return
process_array:
process_array:
process_array_0:
  10: 23 0 0 0             // u32([fp + 0], [fp + 1]) = u32(0)
  11: 9 0 2 _              // [fp + 2] = 0
  12: 4 2 0 3              // [fp + 3] = [fp + 2] + 0
  13: 19 0 0 0 4           // u32([fp + 4], [fp + 5]) = u32([fp + 0], [fp + 1]) + u32(0, 0)
process_array_1:
  14: 1 3 2147483642 6     // [fp + 6] = [fp + 3] op [fp + -5]
  15: 14 6 3 _             // if [fp + 6] != 0 jmp rel not_zero_0
  16: 9 1 6 _              // [fp + 6] = 1
  17: 13 2 _ _             // jump rel end_1
not_zero_0:
  18: 9 0 6 _              // [fp + 6] = 0
end_1:
  19: 14 6 5 _             // if [fp + 6] != 0 jmp rel process_array_3
  20: 13 5 _ _             // jump rel process_array_4
process_array_2:
  21: 4 4 0 2147483643     // Return value 0 slot 0: [fp -4] = [fp + 4] + 0
  22: 4 5 0 2147483644     // Return value 0 slot 1: [fp -3] = [fp + 5] + 0
  23: 11 _ _ _             // return
process_array_3:
  24: 13 2147483644 _ _    // jump rel process_array_2
process_array_4:
  25: 6 3 2 14             // [fp + 14] = [fp + 3] * 2 - Scale index by element size
  26: 42 2147483641 14 7   // [fp + 7] = [[fp + -6] + [fp + 14]]
  27: 4 14 1 15            // [fp + 15] = [fp + 14] + 1 (offset for slot 1)
  28: 42 2147483641 15 8   // [fp + 8] = [[fp + -6] + [fp + 15]] (slot 1)
  29: 15 4 7 9             // u32([fp + 9], [fp + 10]) = u32([fp + 4], [fp + 5]) U32Add u32([fp + 7], [fp + 8])
  30: 6 3 2 16             // [fp + 16] = [fp + 3] * 2 - Scale index by element size
  31: 42 2147483641 16 11  // [fp + 11] = [[fp + -6] + [fp + 16]]
  32: 4 16 1 17            // [fp + 17] = [fp + 16] + 1 (offset for slot 1)
  33: 42 2147483641 17 12  // [fp + 12] = [[fp + -6] + [fp + 17]] (slot 1)
  34: 6 3 2 18             // [fp + 18] = [fp + 3] * 2 (scale index for elem size)
  35: 23 0 0 19            // [fp + 19], [fp + 20] = u32(0)
  36: 45 2147483641 18 19  // [[fp + -6] + [fp + 18]] = [fp + 19] (u32 slot 0)
  37: 4 18 1 21            // [fp + 21] = [fp + 18] + 1 (adjust for slot 1)
  38: 45 2147483641 21 20  // [[fp + -6] + [fp + 21]] = [fp + 20] (u32 slot 1)
  39: 4 3 1 13             // [fp + 13] = [fp + 3] + 1
  40: 4 13 0 3             // [fp + 3] = [fp + 13] + 0
  41: 19 9 0 0 4           // u32([fp + 4], [fp + 5]) = u32([fp + 9], [fp + 10]) + u32(0, 0)
  42: 13 2147483618 _ _    // jump rel process_array_1
