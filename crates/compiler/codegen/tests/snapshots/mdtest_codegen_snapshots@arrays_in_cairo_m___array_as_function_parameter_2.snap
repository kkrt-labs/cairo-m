---
source: crates/compiler/codegen/tests/mdtest_snapshots.rs
description: "Codegen snapshot for mdtest: Arrays in Cairo-M - Array as Function Parameter 2"
input_file: mdtest/01-basics/05-arrays.md
---
Source:
fn use_array_parameter() -> u32 {
    let my_array: [u32; 3] = [1, 2, 3];
    return process_array(my_array, 3felt);
}

fn process_array(arr: [u32; 3], size: felt) -> u32 {
    let sum: u32 = 0;
    let i = 0;
    loop {
        if i == size {
            break;
        }
        sum = sum + arr[i];
        arr[i] = 0;
        i = i + 1;
    }
    return sum;
}
============================================================
Generated CASM:
use_array_parameter:
use_array_parameter:
use_array_parameter_0:
   0: 23 1 0 3             // [fp + 3], [fp + 4] = u32(1)
   1: 23 2 0 5             // [fp + 5], [fp + 6] = u32(2)
   2: 23 3 0 7             // [fp + 7], [fp + 8] = u32(3)
   3: 43 3 0 _             // [fp + 0] = fp + 3
   4: 4 0 0 9              // Arg 0 slot 0: [fp + 9] = [fp + 0] + 0
   5: 9 3 10 _             // Arg 1: [fp + 10] = 3
   6: 10 13 10 _           // call process_array
   7: 4 11 0 2147483643    // Return value 0 slot 0: [fp -4] = [fp + 11] + 0
   8: 4 12 0 2147483644    // Return value 0 slot 1: [fp -3] = [fp + 12] + 0
   9: 11 _ _ _             // return
process_array:
process_array:
process_array_0:
  10: 23 0 0 0             // u32([fp + 0], [fp + 1]) = u32(0)
  11: 9 0 2 _              // [fp + 2] = 0
  12: 4 2 0 3              // [fp + 3] = [fp + 2] + 0
  13: 4 2147483641 0 4     // [fp + 4] = [fp + -6] + 0 (array pointer)
  14: 19 0 0 0 5           // u32([fp + 5], [fp + 6]) = u32([fp + 0], [fp + 1]) + u32(0, 0)
process_array_1:
  15: 1 3 2147483642 7     // [fp + 7] = [fp + 3] op [fp + -5]
  16: 14 7 3 _             // if [fp + 7] != 0 jmp rel not_zero_0
  17: 9 1 7 _              // [fp + 7] = 1
  18: 12 21 _ _            // jump abs end_1
not_zero_0:
  19: 9 0 7 _              // [fp + 7] = 0
end_1:
  20: 14 7 5 _             // if [fp + 7] != 0 jmp rel process_array_3
  21: 12 27 _ _            // jump abs process_array_4
process_array_2:
  22: 4 5 0 2147483643     // Return value 0 slot 0: [fp -4] = [fp + 5] + 0
  23: 4 6 0 2147483644     // Return value 0 slot 1: [fp -3] = [fp + 6] + 0
  24: 11 _ _ _             // return
process_array_3:
  25: 12 23 _ _            // jump abs process_array_2
process_array_4:
  26: 6 3 2 14             // [fp + 14] = [fp + 3] * 2 - Scale index by element size
  27: 42 4 14 8            // [fp + 8] = [[fp + 4] + [fp + 14]]
  28: 4 14 1 15            // [fp + 15] = [fp + 14] + 1 (offset for slot 1)
  29: 42 4 15 9            // [fp + 9] = [[fp + 4] + [fp + 15]] (slot 1)
  30: 15 5 8 10            // u32([fp + 10], [fp + 11]) = u32([fp + 5], [fp + 6]) U32Add u32([fp + 8], [fp + 9])
  31: 6 3 2 16             // [fp + 16] = [fp + 3] * 2 - Scale index by element size
  32: 4 4 0 12             // [fp + 12] = [fp + 4] + 0 (copy array pointer)
  33: 23 0 0 17            // [fp + 17], [fp + 18] = u32(0)
  34: 45 4 16 17           // [[fp + 4] + [fp + 16]] = [fp + 17] (u32 slot 0)
  35: 4 16 1 19            // [fp + 19] = [fp + 16] + 1 (adjust for slot 1)
  36: 45 4 19 18           // [[fp + 4] + [fp + 19]] = [fp + 18] (u32 slot 1)
  37: 4 3 1 13             // [fp + 13] = [fp + 3] + 1
  38: 4 13 0 3             // [fp + 3] = [fp + 13] + 0
  39: 4 12 0 4             // [fp + 4] = [fp + 12] + 0 (array pointer)
  40: 19 10 0 0 5          // u32([fp + 5], [fp + 6]) = u32([fp + 10], [fp + 11]) + u32(0, 0)
  41: 12 16 _ _            // jump abs process_array_1
