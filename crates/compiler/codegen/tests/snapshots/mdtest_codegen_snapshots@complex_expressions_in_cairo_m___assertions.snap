---
source: crates/compiler/codegen/tests/mdtest_snapshots.rs
description: "Codegen snapshot for mdtest: Complex Expressions in Cairo-M - Assertions"
input_file: mdtest/01-basics/06-expressions.md
---
Source:
fn test_assert() {
    let x: u32 = 10;
    assert(x == 10);
    assert(x>5 == true);
    assert(!(x<10) == true);

    let y: felt = 15;
    assert(y != 12);

    let tt = true;
    assert(tt == true);

    let ff = false;
    assert(!ff == true);
    return;
}
============================================================
Generated CASM:
test_assert:
test_assert:
test_assert_0:
   0: 23 10 0 0            // u32([fp + 0], [fp + 1]) = u32(10)
   1: 30 0 10 0 2          // [fp + 2] = u32([fp + 0], [fp + 1]) U32Eq u32(10, 0) /* imm = 0x0000000a */
   2: 50 2 1 _             // assert [fp + 2] == 1
   3: 23 5 0 15            // [fp + 15], [fp + 16] = u32(5)
   4: 28 15 0 3            // [fp + 3] = u32([fp + 15], [fp + 16]) U32Less u32([fp + 0], [fp + 1])
   5: 4 3 2147483646 4     // [fp + 4] = [fp + 3] + (-1) (-1 as M31 -> 2147483646 (=-1 mod M31))
   6: 14 4 3 _             // if [fp + 4] != 0 jmp rel not_zero_0
   7: 9 1 4 _              // [fp + 4] = 1
   8: 13 2 _ _             // jump rel end_1
not_zero_0:
   9: 9 0 4 _              // [fp + 4] = 0
end_1:
  10: 50 4 1 _             // assert [fp + 4] == 1
  11: 34 0 10 0 5          // [fp + 5] = u32([fp + 0], [fp + 1]) U32Less u32(10, 0) /* imm = 0x0000000a */
  12: 14 5 3 _             // if [fp + 5] != 0 jmp rel not_zero_2
  13: 9 1 6 _              // [fp + 6] = 1
  14: 13 2 _ _             // jump rel not_end_3
not_zero_2:
  15: 9 0 6 _              // [fp + 6] = 0
not_end_3:
  16: 4 6 2147483646 7     // [fp + 7] = [fp + 6] + (-1) (-1 as M31 -> 2147483646 (=-1 mod M31))
  17: 14 7 3 _             // if [fp + 7] != 0 jmp rel not_zero_4
  18: 9 1 7 _              // [fp + 7] = 1
  19: 13 2 _ _             // jump rel end_5
not_zero_4:
  20: 9 0 7 _              // [fp + 7] = 0
end_5:
  21: 50 7 1 _             // assert [fp + 7] == 1
  22: 9 15 8 _             // [fp + 8] = 15
  23: 4 8 2147483635 9     // [fp + 9] = [fp + 8] + (-12) (-12 as M31 -> 2147483635 (=-12 mod M31))
  24: 14 9 3 _             // if [fp + 9] != 0 jmp rel neq_non_zero_6
  25: 9 0 9 _              // [fp + 9] = 0
  26: 13 2 _ _             // jump rel neq_end_7
neq_non_zero_6:
  27: 9 1 9 _              // [fp + 9] = 1
neq_end_7:
  28: 50 9 1 _             // assert [fp + 9] == 1
  29: 9 1 10 _             // [fp + 10] = true
  30: 4 10 2147483646 11   // [fp + 11] = [fp + 10] + (-1) (-1 as M31 -> 2147483646 (=-1 mod M31))
  31: 14 11 3 _            // if [fp + 11] != 0 jmp rel not_zero_8
  32: 9 1 11 _             // [fp + 11] = 1
  33: 13 2 _ _             // jump rel end_9
not_zero_8:
  34: 9 0 11 _             // [fp + 11] = 0
end_9:
  35: 50 11 1 _            // assert [fp + 11] == 1
  36: 9 0 12 _             // [fp + 12] = false
  37: 14 12 3 _            // if [fp + 12] != 0 jmp rel not_zero_10
  38: 9 1 13 _             // [fp + 13] = 1
  39: 13 2 _ _             // jump rel not_end_11
not_zero_10:
  40: 9 0 13 _             // [fp + 13] = 0
not_end_11:
  41: 4 13 2147483646 14   // [fp + 14] = [fp + 13] + (-1) (-1 as M31 -> 2147483646 (=-1 mod M31))
  42: 14 14 3 _            // if [fp + 14] != 0 jmp rel not_zero_12
  43: 9 1 14 _             // [fp + 14] = 1
  44: 13 2 _ _             // jump rel end_13
not_zero_12:
  45: 9 0 14 _             // [fp + 14] = 0
end_13:
  46: 50 14 1 _            // assert [fp + 14] == 1
  47: 11 _ _ _             // return
