---
source: crates/compiler/codegen/tests/mdtest_snapshots.rs
description: "Codegen snapshot for mdtest: Complex Expressions in Cairo-M - Nested Function Calls in Expressions"
input_file: mdtest/01-basics/06-expressions.md
---
Source:
fn compute_base(x: felt) -> felt {
    return x * 2;
}

fn compute_offset(y: felt) -> felt {
    return y + 5;
}

fn test_function_expressions() -> felt {
    let a = 7;
    let b = 3;

    // Function calls in expressions
    let result1 = compute_base(a) + compute_offset(b);     // (7 * 2) + (3 + 5) = 14 + 8 = 22
    let result2 = compute_base(a + b) - compute_offset(1); // (10 * 2) - (1 + 5) = 20 - 6 = 14

    // Nested function calls
    let result3 = compute_base(compute_offset(a));         // compute_base(7 + 5) = compute_base(12) = 24

    return result1 + result2 + result3;                    // 22 + 14 + 24 = 60
}
============================================================
Generated CASM:
compute_base:
compute_base:
compute_base_0:
   0: 6 -4 2 -3            // [fp + -3] = [fp + -4] op 2
   1: 11 _ _ _             // return
compute_offset:
compute_offset:
compute_offset_0:
   2: 4 -4 5 -3            // [fp + -3] = [fp + -4] op 5
   3: 11 _ _ _             // return
test_function_expressions:
test_function_expressions:
test_function_expressions_0:
   4: 9 7 0 _              // [fp + 0] = 7
   5: 9 3 1 _              // [fp + 1] = 3
   6: 4 0 0 13             // Arg 0 slot 0: [fp + 13] = [fp + 0] + 0
   7: 10 15 0 _            // call compute_base
   8: 4 1 0 16             // Arg 0 slot 0: [fp + 16] = [fp + 1] + 0
   9: 10 18 2 _            // call compute_offset
  10: 0 14 17 4            // [fp + 4] = [fp + 14] op [fp + 17]
  11: 0 0 1 19             // [fp + 19] = [fp + 0] op [fp + 1]
  12: 10 21 0 _            // call compute_base
  13: 9 1 22 _             // Arg 0: [fp + 22] = 1
  14: 10 24 2 _            // call compute_offset
  15: 1 20 23 8            // [fp + 8] = [fp + 20] op [fp + 23]
  16: 4 0 0 25             // Arg 0 slot 0: [fp + 25] = [fp + 0] + 0
  17: 10 27 2 _            // call compute_offset
  18: 10 28 0 _            // call compute_base
  19: 0 4 8 11             // [fp + 11] = [fp + 4] op [fp + 8]
  20: 0 11 27 -3           // [fp + -3] = [fp + 11] op [fp + 27]
  21: 11 _ _ _             // return
