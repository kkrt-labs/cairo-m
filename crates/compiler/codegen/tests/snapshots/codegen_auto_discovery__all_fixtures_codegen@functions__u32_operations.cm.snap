---
source: crates/compiler/codegen/tests/codegen_auto_discovery.rs
description: Codegen snapshot for functions/u32_operations.cm
input_file: test_data/functions/u32_operations.cm
---
Fixture: functions/u32_operations.cm
============================================================
Source code:
fn add(a: u32, b: u32) -> u32 {
    // Simple u32 addition
    let result: u32 = a + b;
    let one: u32 = 1;
    let result2: u32 = result + one;
    return result2;
}

fn sub(a: u32, b: u32) -> u32 {
    // Simple u32 subtraction
    let result: u32 = a - b;
    let one: u32 = 1;
    let result2: u32 = result - one;
    return result2;
}

fn mul(a: u32, b: u32) -> u32 {
    // Simple u32 multiplication
    let result: u32 = a * b;
    let two: u32 = 2;
    let result2: u32 = result * two;
    return result2;
}

fn div(a: u32, b: u32) -> u32 {
    // Simple u32 division
    let result: u32 = a / b;
    let two: u32 = 2;
    let result2: u32 = result / two;
    return result2;
}

fn get_u32_literal() -> u32 {
    // Return a literal that should be inferred as u32
    return 42;
}

============================================================
Generated CASM:
add:
   0: 15 -8 -6 0           // u32([fp + 0], [fp + 0 + 1]) = u32([fp + -8], [fp + -8 + 1]) op u32([fp + -6], [fp + -6 + 1])
   1: 23 1 0 2             // [fp + 2, fp + 2 + 1] = u32(1)
   2: 15 0 2 4             // u32([fp + 4], [fp + 4 + 1]) = u32([fp + 0], [fp + 0 + 1]) op u32([fp + 2], [fp + 2 + 1])
   3: 4 4 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 4] + 0
   4: 4 5 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 5] + 0
   5: 11 _ _ _             // return
sub:
   6: 16 -8 -6 0           // u32([fp + 0], [fp + 0 + 1]) = u32([fp + -8], [fp + -8 + 1]) op u32([fp + -6], [fp + -6 + 1])
   7: 23 1 0 2             // [fp + 2, fp + 2 + 1] = u32(1)
   8: 16 0 2 4             // u32([fp + 4], [fp + 4 + 1]) = u32([fp + 0], [fp + 0 + 1]) op u32([fp + 2], [fp + 2 + 1])
   9: 4 4 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 4] + 0
  10: 4 5 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 5] + 0
  11: 11 _ _ _             // return
mul:
  12: 17 -8 -6 0           // u32([fp + 0], [fp + 0 + 1]) = u32([fp + -8], [fp + -8 + 1]) op u32([fp + -6], [fp + -6 + 1])
  13: 23 2 0 2             // [fp + 2, fp + 2 + 1] = u32(2)
  14: 17 0 2 4             // u32([fp + 4], [fp + 4 + 1]) = u32([fp + 0], [fp + 0 + 1]) op u32([fp + 2], [fp + 2 + 1])
  15: 4 4 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 4] + 0
  16: 4 5 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 5] + 0
  17: 11 _ _ _             // return
div:
  18: 18 -8 -6 0           // u32([fp + 0], [fp + 0 + 1]) = u32([fp + -8], [fp + -8 + 1]) op u32([fp + -6], [fp + -6 + 1])
  19: 23 2 0 2             // [fp + 2, fp + 2 + 1] = u32(2)
  20: 18 0 2 4             // u32([fp + 4], [fp + 4 + 1]) = u32([fp + 0], [fp + 0 + 1]) op u32([fp + 2], [fp + 2 + 1])
  21: 4 4 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 4] + 0
  22: 4 5 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 5] + 0
  23: 11 _ _ _             // return
get_u32_literal:
get_u32_literal:
get_u32_literal_0:
  24: 9 42 -4 _            // Return value 0: [fp -4] = 42
  25: 11 _ _ _             // return
