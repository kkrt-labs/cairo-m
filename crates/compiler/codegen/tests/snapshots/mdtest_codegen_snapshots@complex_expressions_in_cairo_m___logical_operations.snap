---
source: crates/compiler/codegen/tests/mdtest_snapshots.rs
description: "Codegen snapshot for mdtest: Complex Expressions in Cairo-M - Logical Operations"
input_file: mdtest/01-basics/06-expressions.md
---
Source:
fn test_logical_ops() -> felt {
    let a = 5;
    let b = 0;
    let c = 3;

    // Logical AND: both operands must be non-zero
    let and_result1 = (a != 0) && (c != 0);  // 1 (true && true)
    let and_result2 = (a != 0) && (b != 0);  // 0 (true && false)

    // Logical OR: at least one operand must be non-zero
    let or_result1 = (a != 0) || (b != 0);   // 1 (true || false)
    let or_result2 = (b != 0) || (b != 0);   // 0 (false || false)

    let res = 0;
    if and_result1 {
        res = res + 1;
    }
    if and_result2 {
        res = res + 1;
    }
    if or_result1 {
        res = res + 1;
    }
    if or_result2 {
        res = res + 1;
    }
    return res;
}
============================================================
Generated CASM:
test_logical_ops:
test_logical_ops:
test_logical_ops_0:
   0: 9 5 0 _              // [fp + 0] = 5
   1: 9 0 1 _              // [fp + 1] = 0
   2: 9 3 2 _              // [fp + 2] = 3
   3: 5 0 0 3              // [fp + 3] = [fp + 0] op 0
   4: 14 3 3 _             // if [fp + 3] != 0, jump to neq_non_zero_0
   5: 9 0 3 _              // [fp + 3] = 0
   6: 12 8 _ _             // jump to neq_end_1
neq_non_zero_0:
   7: 9 1 3 _              // [fp + 3] = 1
neq_end_1:
   8: 5 2 0 4              // [fp + 4] = [fp + 2] op 0
   9: 14 4 3 _             // if [fp + 4] != 0, jump to neq_non_zero_2
  10: 9 0 4 _              // [fp + 4] = 0
  11: 12 13 _ _            // jump to neq_end_3
neq_non_zero_2:
  12: 9 1 4 _              // [fp + 4] = 1
neq_end_3:
  13: 2 3 4 5              // [fp + 5] = [fp + 3] op [fp + 4]
  14: 14 5 3 _             // if [fp + 5] != 0, jump to and_non_zero_4
  15: 9 0 5 _              // [fp + 5] = 0
  16: 12 18 _ _            // jump to and_end_5
and_non_zero_4:
  17: 9 1 5 _              // [fp + 5] = 1
and_end_5:
  18: 5 0 0 6              // [fp + 6] = [fp + 0] op 0
  19: 14 6 3 _             // if [fp + 6] != 0, jump to neq_non_zero_6
  20: 9 0 6 _              // [fp + 6] = 0
  21: 12 23 _ _            // jump to neq_end_7
neq_non_zero_6:
  22: 9 1 6 _              // [fp + 6] = 1
neq_end_7:
  23: 5 1 0 7              // [fp + 7] = [fp + 1] op 0
  24: 14 7 3 _             // if [fp + 7] != 0, jump to neq_non_zero_8
  25: 9 0 7 _              // [fp + 7] = 0
  26: 12 28 _ _            // jump to neq_end_9
neq_non_zero_8:
  27: 9 1 7 _              // [fp + 7] = 1
neq_end_9:
  28: 2 6 7 8              // [fp + 8] = [fp + 6] op [fp + 7]
  29: 14 8 3 _             // if [fp + 8] != 0, jump to and_non_zero_10
  30: 9 0 8 _              // [fp + 8] = 0
  31: 12 33 _ _            // jump to and_end_11
and_non_zero_10:
  32: 9 1 8 _              // [fp + 8] = 1
and_end_11:
  33: 5 0 0 9              // [fp + 9] = [fp + 0] op 0
  34: 14 9 3 _             // if [fp + 9] != 0, jump to neq_non_zero_12
  35: 9 0 9 _              // [fp + 9] = 0
  36: 12 38 _ _            // jump to neq_end_13
neq_non_zero_12:
  37: 9 1 9 _              // [fp + 9] = 1
neq_end_13:
  38: 5 1 0 10             // [fp + 10] = [fp + 1] op 0
  39: 14 10 3 _            // if [fp + 10] != 0, jump to neq_non_zero_14
  40: 9 0 10 _             // [fp + 10] = 0
  41: 12 43 _ _            // jump to neq_end_15
neq_non_zero_14:
  42: 9 1 10 _             // [fp + 10] = 1
neq_end_15:
  43: 9 0 11 _             // Initialize OR result to 0
  44: 14 9 3 _             // if [fp + 9] != 0, jump to or_true_16
  45: 14 10 2 _            // if [fp + 10] != 0, jump to or_true_16
  46: 12 48 _ _            // jump to or_end_17
or_true_16:
  47: 9 1 11 _             // [fp + 11] = 1
or_end_17:
  48: 5 1 0 12             // [fp + 12] = [fp + 1] op 0
  49: 14 12 3 _            // if [fp + 12] != 0, jump to neq_non_zero_18
  50: 9 0 12 _             // [fp + 12] = 0
  51: 12 53 _ _            // jump to neq_end_19
neq_non_zero_18:
  52: 9 1 12 _             // [fp + 12] = 1
neq_end_19:
  53: 5 1 0 13             // [fp + 13] = [fp + 1] op 0
  54: 14 13 3 _            // if [fp + 13] != 0, jump to neq_non_zero_20
  55: 9 0 13 _             // [fp + 13] = 0
  56: 12 58 _ _            // jump to neq_end_21
neq_non_zero_20:
  57: 9 1 13 _             // [fp + 13] = 1
neq_end_21:
  58: 9 0 14 _             // Initialize OR result to 0
  59: 14 12 3 _            // if [fp + 12] != 0, jump to or_true_22
  60: 14 13 2 _            // if [fp + 13] != 0, jump to or_true_22
  61: 12 63 _ _            // jump to or_end_23
or_true_22:
  62: 9 1 14 _             // [fp + 14] = 1
or_end_23:
  63: 9 0 15 _             // [fp + 15] = 0
  64: 14 5 2 _             // if [fp + 5] != 0 jmp rel test_logical_ops_1
  65: 12 68 _ _            // jump abs test_logical_ops_2
test_logical_ops_1:
  66: 4 15 0 20            // [fp + 20] = [fp + 15] + 0
  67: 4 20 1 15            // [fp + 15] = [fp + 20] op 1
test_logical_ops_2:
  68: 14 8 2 _             // if [fp + 8] != 0 jmp rel test_logical_ops_3
  69: 12 72 _ _            // jump abs test_logical_ops_4
test_logical_ops_3:
  70: 4 15 0 20            // [fp + 20] = [fp + 15] + 0
  71: 4 20 1 15            // [fp + 15] = [fp + 20] op 1
test_logical_ops_4:
  72: 14 11 2 _            // if [fp + 11] != 0 jmp rel test_logical_ops_5
  73: 12 76 _ _            // jump abs test_logical_ops_6
test_logical_ops_5:
  74: 4 15 0 20            // [fp + 20] = [fp + 15] + 0
  75: 4 20 1 15            // [fp + 15] = [fp + 20] op 1
test_logical_ops_6:
  76: 14 14 2 _            // if [fp + 14] != 0 jmp rel test_logical_ops_7
  77: 12 80 _ _            // jump abs test_logical_ops_8
test_logical_ops_7:
  78: 4 15 0 20            // [fp + 20] = [fp + 15] + 0
  79: 4 20 1 15            // [fp + 15] = [fp + 20] op 1
test_logical_ops_8:
  80: 4 15 0 -3            // Return value 0: [fp -3] = [fp + 15] + 0
  81: 11 _ _ _             // return
