---
source: crates/compiler/codegen/tests/mdtest_snapshots.rs
description: "Codegen snapshot for mdtest: Arrays in Cairo-M - Array as Function Parameter"
input_file: mdtest/01-basics/05-arrays.md
---
Source:
fn process_array(arr: [u32; 3], size: u32) -> u32 {
    let sum: u32 = 0;
    let i = 0u32;
    loop {
        if (i == size) {
            break;
        }
        sum = sum + arr[i];
        arr[i] = 0;
        i = i + 1;
    }
    return sum;
}

fn use_array_parameter() -> u32 {
    let my_array: [u32; 3] = [1, 2, 3];
    return process_array(my_array, 3u32);
}
============================================================
Generated CASM:
process_array:
process_array:
process_array_0:
   0: 23 0 0 0             // u32([fp + 0], [fp + 1]) = u32(0)
   1: 23 0 0 2             // u32([fp + 2], [fp + 3]) = u32(0)
   2: 19 2 0 0 4           // u32([fp + 4], [fp + 5]) = u32([fp + 2], [fp + 3]) + u32(0, 0)
   3: 4 -7 0 6             // [fp + 6] = [fp + -7] + 0 (array pointer)
   4: 19 0 0 0 7           // u32([fp + 7], [fp + 8]) = u32([fp + 0], [fp + 1]) + u32(0, 0)
process_array_1:
   5: 24 4 -6 16           // [fp + 16] = u32([fp + 4], [fp + 5]) U32Eq u32([fp + -6], [fp + -5])
   6: 14 16 5 _            // if [fp + 16] != 0 jmp rel process_array_3
   7: 12 14 _ _            // jump abs process_array_4
process_array_2:
   8: 4 7 0 -4             // Return value 0 slot 0: [fp -4] = [fp + 7] + 0
   9: 4 8 0 -3             // Return value 0 slot 1: [fp -3] = [fp + 8] + 0
  10: 11 _ _ _             // return
process_array_3:
  11: 12 10 _ _            // jump abs process_array_2
process_array_4:
  12: 6 4 2 17             // [fp + 17] = [fp + 4] * 2 (scale index by element size)
  13: 42 6 17 9            // [fp + 9] = [[fp + 6] + [fp + 17]]
  14: 4 17 1 18            // [fp + 18] = [fp + 17] + 1 (offset for slot 1)
  15: 42 6 18 10           // [fp + 10] = [[fp + 6] + [fp + 18]] (slot 1)
  16: 15 7 9 11            // u32([fp + 11], [fp + 12]) = u32([fp + 7], [fp + 8]) U32Add u32([fp + 9], [fp + 10])
  17: 6 4 2 19             // [fp + 19] = [fp + 4] * 2 (scale index by element size)
  18: 4 6 0 13             // [fp + 13] = [fp + 6] + 0 (copy array pointer)
  19: 9 0 20 _             // [fp + 20] = 0
  20: 45 6 19 20           // [[fp + 6] + [fp + 19]] = [fp + 20]
  21: 19 4 1 0 14          // u32([fp + 14], [fp + 15]) = u32([fp + 4], [fp + 5]) U32Add u32(1, 0)
  22: 19 14 0 0 4          // u32([fp + 4], [fp + 5]) = u32([fp + 14], [fp + 15]) + u32(0, 0)
  23: 4 13 0 6             // [fp + 6] = [fp + 13] + 0 (array pointer)
  24: 19 11 0 0 7          // u32([fp + 7], [fp + 8]) = u32([fp + 11], [fp + 12]) + u32(0, 0)
  25: 12 7 _ _             // jump abs process_array_1
use_array_parameter:
use_array_parameter_0:
  26: 23 1 0 3             // [fp + 3], [fp + 4] = u32(1)
  27: 23 2 0 5             // [fp + 5], [fp + 6] = u32(2)
  28: 23 3 0 7             // [fp + 7], [fp + 8] = u32(3)
  29: 43 3 0 _             // [fp + 0] = fp + 3
  30: 4 0 0 9              // Arg 0 slot 0: [fp + 9] = [fp + 0] + 0
use_array_parameter:
  31: 23 3 0 15            // Arg 1: [fp + 15] = 3
  32: 10 14 0 _            // call process_array
  33: 4 12 0 -4            // Return value 0 slot 0: [fp -4] = [fp + 12] + 0
  34: 4 13 0 -3            // Return value 0 slot 1: [fp -3] = [fp + 13] + 0
  35: 11 _ _ _             // return
