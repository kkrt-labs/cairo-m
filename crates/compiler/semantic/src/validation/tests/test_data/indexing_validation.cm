// Test cases for indexing validation

// Valid indexing cases
func valid_indexing() -> felt {
    // Tuple indexing
    let tup = (1, 2, 3);
    let first = tup[0];
    let second = tup[1];
    let third = tup[2];
    return third;
}

struct Point{
    x: felt,
    y: felt,
}

// Invalid indexing cases
func invalid_indexing() -> felt{
    // Indexing non-indexable types
    let num = 42;
    let bad1 = num[0];  // Should error: cannot index felt

    // Non-integer indices
    let tup = (1, 2, 3);
    let bad2 = tup[Point{x: 0, y: 0}];  // Should error: index must be felt

    // Out of bounds (when possible to detect)
    let small_tup = (1, 2);
    let bad3 = small_tup[2];  // TODO Should error: index out of bounds
    return 0;
} 
