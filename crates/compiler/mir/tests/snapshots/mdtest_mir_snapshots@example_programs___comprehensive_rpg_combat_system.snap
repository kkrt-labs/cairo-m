---
source: crates/compiler/mir/tests/mdtest_snapshots.rs
description: "MIR snapshot for mdtest: Example Programs - Comprehensive RPG Combat System"
input_file: mdtest/07-example-programs/example-00.md
---
Source:
// Struct definitions showing custom types
struct Character {
    health: u32,
    mana: u32,
    level: u32,
    position: Position,
}

struct Position {
    x: u32,
    y: u32,
}

struct CombatResult {
    damage_dealt: u32,
    critical_hit: bool,
    remaining_health: u32,
}


// Entry point demonstrating tuple usage and multiple features
fn main_test() -> u32 {
    let battle_result = simulate_full_battle();

    // Create a summary tuple
    let summary = get_character_stats(Character {
        health: 100,
        mana: 50,
        level: 5,
        position: Position { x: 0, y: 0 },
    });

    // Extract tuple values
    let (health, mana, level) = summary;

    // Combine results using both felt and u32 arithmetic
    let final_score: u32 = battle_result + level;  // u32 + u32 in felt context
    let bonus_score = mana / 10u32;  // felt arithmetic

    return final_score + bonus_score;
}


// Function demonstrating tuples as return types
fn get_character_stats(char: Character) -> (u32, u32, u32) {
    return (char.health, char.mana, char.level);
}

// Function with complex struct manipulation and arithmetic
fn calculate_distance_squared(pos1: Position, pos2: Position) -> u32 {
    let dx = pos1.x - pos2.x;
    let dy = pos1.y - pos2.y;
    return dx * dx + dy * dy;
}

// Function demonstrating control flow and u32/felt operations
fn calculate_damage(attacker_level: u32, defender_level: u32, distance: u32) -> u32 {
    let base_damage: u32 = 10;
    let level_bonus = attacker_level * 2;

    // Convert felt to rough u32 for distance penalty (simplified)
    let distance_penalty: u32 = 0;
    if (distance > 100) {
        distance_penalty = 5;
    } else {
        if (distance > 50) {
            distance_penalty = 2;
        }
    }

    let total_damage = base_damage + level_bonus;
    if (total_damage > distance_penalty) {
        return total_damage - distance_penalty;
    } else {
        return 1;  // Minimum damage
    }
}

// Function showing loops and complex logic
fn perform_combat(attacker: Character, defender: Character) -> CombatResult {
    let distance = calculate_distance_squared(attacker.position, defender.position);
    let base_damage = calculate_damage(attacker.level, defender.level, distance);

    // Critical hit calculation using felt arithmetic
    let critical_multiplier = attacker.mana / 10u32;  // u32 division
    let is_critical: bool = false;
    let final_damage = base_damage;

    if (critical_multiplier > 5) {
        is_critical = true;
        final_damage = base_damage * 2;
    }

    // Apply damage with bounds checking
    let new_health = defender.health;
    if (final_damage >= defender.health) {
        new_health = 0;
    } else {
        new_health = defender.health - final_damage;
    }

    let res = CombatResult {
        damage_dealt: final_damage,
        critical_hit: is_critical,
        remaining_health: new_health,
    };
    return res;
}

// Function demonstrating multiple function calls and tuple destructuring
fn simulate_battle_round(hero: Character, enemy: Character) -> u32 {
    // Hero attacks enemy
    let hero_attack = perform_combat(hero, enemy);
    let enemy_health = hero_attack.remaining_health;

    // Enemy counter-attacks if still alive
    if (enemy_health > 0) {
        let enemy_counter = perform_combat(enemy, hero);
        let hero_health = enemy_counter.remaining_health;

        // Return 1 if hero wins, 2 if enemy wins, 0 if both alive
        if (enemy_health == 0) {
            return 1;  // Hero wins
        } else {
            if (hero_health == 0) {
                return 2;  // Enemy wins
            } else {
                return 0;  // Both alive, continue battle
            }
        }
    } else {
        return 1;  // Hero wins immediately
    }
}

// Main function demonstrating variable mutation and comprehensive example
fn simulate_full_battle() -> u32 {
    // Create characters using struct literals
    let hero = Character {
        health: 100,
        mana: 50,
        level: 5,
        position: Position { x: 10, y: 20 },
    };

    let enemy = Character {
        health: 80,
        mana: 30,
        level: 4,
        position: Position { x: 15, y: 25 },
    };

    // Battle loop with mutation
    let current_hero = hero;
    let current_enemy = enemy;
    let round: u32 = 1;
    let max_rounds: u32 = 10;

    // Simulate multiple battle rounds
    loop {
        if (round > max_rounds) {
            break;  // Draw after max rounds
        }

        let result = simulate_battle_round(current_hero, current_enemy);

        if (result == 1) {
            return 1;  // Hero victory
        } else {
            if (result == 2) {
                return 2;  // Enemy victory
            }
        }

        // Update for next round (simplified - reduce both healths)
        if (current_hero.health > 10) {
            current_hero.health = current_hero.health - 5;
        }
        if (current_enemy.health > 8) {
            current_enemy.health = current_enemy.health - 4;
        }

        round = round + 1;
    }

    return 0;  // Draw
}
============================================================
Generated MIR:
module {
  // Function 0
  fn main_test {
    entry: 0

    0:
      %0 = call 6()
      // Lowered struct alloca for %1
%16 = framealloc Position
      // Get address of field 'x'
%17 = getelementptr %16, 0
      // Store field 'x'
store %17, 0 (u32)
      // Get address of field 'y'
%18 = getelementptr %16, 2
      // Store field 'y'
store %18, 0 (u32)
      // Alias struct value to alloca
%1 = %16 (*Position)
      // Lowered struct alloca for %2
%19 = framealloc Character
      // Get address of field 'health'
%20 = getelementptr %19, 0
      // Store field 'health'
store %20, 100 (u32)
      // Get address of field 'mana'
%21 = getelementptr %19, 2
      // Store field 'mana'
store %21, 50 (u32)
      // Get address of field 'level'
%22 = getelementptr %19, 4
      // Store field 'level'
store %22, 5 (u32)
      // Get address of field 'position'
%23 = getelementptr %19, 6
      // Store field 'position'
store %23, %1 (Position)
      // Alias struct value to alloca
%2 = %19 (*Character)
      %3, %4, %5 = call 1(%2)
      // Lowered tuple alloca for %6
%24 = framealloc (u32, u32, u32)
      // Get address (offset 0) of tuple element 0
%25 = getelementptr %24, 0
      // Store tuple element 0
store %25, %3 (u32)
      // Get address (offset 2) of tuple element 1
%26 = getelementptr %24, 2
      // Store tuple element 1
store %26, %4 (u32)
      // Get address (offset 4) of tuple element 2
%27 = getelementptr %24, 4
      // Store tuple element 2
store %27, %5 (u32)
      // Alias tuple value to alloca
%6 = %24 (*(u32, u32, u32))
      // Get address (offset 2) of tuple element 1
%8 = getelementptr %6, 2
      // Load tuple element 1
%9 = load u32 %8
      // Get address (offset 4) of tuple element 2
%10 = getelementptr %6, 4
      // Load tuple element 2
%11 = load u32 %10
      %12 = %0 U32Add %11
      %13 = %9 U32Div 10
      %14 = %12 U32Add %13
      return %14

  }

  // Function 1
  fn get_character_stats {
    parameters: [0]
    entry: 0

    0:
      %1 = extractfield %0, "health"
      %2 = extractfield %0, "mana"
      %3 = extractfield %0, "level"
      return (%1, %2, %3)

  }

  // Function 2
  fn calculate_distance_squared {
    parameters: [0, 1]
    entry: 0

    0:
      %2 = extractfield %0, "x"
      // Get address of field 'x' (lowered)
%12 = getelementptr %16, 0
      // Load field 'x' (lowered)
%3 = load u32 %12
      %4 = %2 U32Sub %3
      %5 = extractfield %0, "y"
      // Get address of field 'y' (lowered)
%13 = getelementptr %16, 0
      // Load field 'y' (lowered)
%6 = load u32 %13
      %7 = %5 U32Sub %6
      %8 = %4 U32Mul %4
      %9 = %7 U32Mul %7
      %10 = %8 U32Add %9
      return %10

  }

  // Function 3
  fn calculate_damage {
    parameters: [0, 1, 2]
    entry: 0

    0:
      %3 = 10 (u32)
      %4 = %0 U32Mul 2
      %5 = 0 (u32)
      %6 = %2 U32Greater 100
      if %6 then jump 1 else jump 2

    1 (block_1):
      ; block_1
      store %5, 5 (u32)
      jump 5

    2 (block_2):
      ; block_2
      %7 = %2 U32Greater 50
      if %7 then jump 3 else jump 4

    3 (block_3):
      ; block_3
      store %5, 2 (u32)
      jump 4

    4 (block_4):
      ; block_4
      jump 5

    5 (block_5):
      ; block_5
      %8 = %3 U32Add %4
      %9 = %8 U32Greater %5
      if %9 then jump 6 else jump 7

    6 (block_6):
      ; block_6
      %10 = %8 U32Sub %5
      return %10

    7 (block_7):
      ; block_7
      return 1

  }

  // Function 4
  fn perform_combat {
    parameters: [0, 1]
    entry: 0

    0:
      %2 = extractfield %0, "position"
      // Get address of field 'position' (lowered)
%20 = getelementptr %16, 0
      // Load field 'position' (lowered)
%3 = load Position %20
      %4 = call 2(%2, %3)
      %5 = extractfield %0, "level"
      // Get address of field 'level' (lowered)
%21 = getelementptr %16, 0
      // Load field 'level' (lowered)
%6 = load u32 %21
      %7 = call 3(%5, %6, %4)
      %8 = extractfield %0, "mana"
      %9 = %8 U32Div 10
      %10 = false (bool)
      %11 = %9 U32Greater 5
      if %11 then jump 1 else jump 2

    1 (block_1):
      ; block_1
      store %10, true (bool)
      %12 = %7 U32Mul 2
      store %7, %12 (u32)
      jump 2

    2 (block_2):
      ; block_2
      // Get address of field 'health' (lowered)
%22 = getelementptr %16, 0
      // Load field 'health' (lowered)
%13 = load u32 %22
      // Get address of field 'health' (lowered)
%23 = getelementptr %16, 0
      // Load field 'health' (lowered)
%14 = load u32 %23
      %15 = %7 U32GreaterEqual %14
      if %15 then jump 3 else jump 4

    3 (block_3):
      ; block_3
      store %13, 0
      jump 5

    4 (block_4):
      ; block_4
      // Get address of field 'health' (lowered)
%24 = getelementptr %16, 0
      // Load field 'health' (lowered)
%16 = load u32 %24
      %17 = %16 U32Sub %7
      store %13, %17 (u32)
      jump 5

    5 (block_5):
      ; block_5
      // Lowered struct alloca for %18
%25 = framealloc CombatResult
      // Get address of field 'damage_dealt'
%26 = getelementptr %25, 0
      // Store field 'damage_dealt'
store %26, %7 (u32)
      // Get address of field 'critical_hit'
%27 = getelementptr %25, 2
      // Store field 'critical_hit'
store %27, %10 (bool)
      // Get address of field 'remaining_health'
%28 = getelementptr %25, 3
      // Store field 'remaining_health'
store %28, %13 (u32)
      // Alias struct value to alloca
%18 = %25 (*CombatResult)
      return %18

  }

  // Function 5
  fn simulate_battle_round {
    parameters: [0, 1]
    entry: 0

    0:
      %2 = call 4(%0, %1)
      // Get address of field 'remaining_health' (lowered)
%10 = getelementptr %19, 0
      // Load field 'remaining_health' (lowered)
%3 = load u32 %10
      %4 = %3 U32Greater 0
      if %4 then jump 1 else jump 2

    1 (block_1):
      ; block_1
      %5 = call 4(%1, %0)
      %6 = extractfield %5, "remaining_health"
      if %3 then jump 4 else jump 3

    2 (block_2):
      ; block_2
      return 1

    3 (block_3):
      ; block_3
      return 1

    4 (block_4):
      ; block_4
      if %6 then jump 6 else jump 5

    5 (block_5):
      ; block_5
      return 2

    6 (block_6):
      ; block_6
      return 0

  }

  // Function 6
  fn simulate_full_battle {
    entry: 0

    0:
      // Lowered struct alloca for %0
%22 = framealloc Position
      // Get address of field 'x'
%23 = getelementptr %22, 0
      // Store field 'x'
store %23, 10 (u32)
      // Get address of field 'y'
%24 = getelementptr %22, 2
      // Store field 'y'
store %24, 20 (u32)
      // Alias struct value to alloca
%0 = %22 (*Position)
      // Lowered struct alloca for %1
%25 = framealloc Character
      // Get address of field 'health'
%26 = getelementptr %25, 0
      // Store field 'health'
store %26, 100 (u32)
      // Get address of field 'mana'
%27 = getelementptr %25, 2
      // Store field 'mana'
store %27, 50 (u32)
      // Get address of field 'level'
%28 = getelementptr %25, 4
      // Store field 'level'
store %28, 5 (u32)
      // Get address of field 'position'
%29 = getelementptr %25, 6
      // Store field 'position'
store %29, %0 (Position)
      // Alias struct value to alloca
%1 = %25 (*Character)
      // Lowered struct alloca for %2
%30 = framealloc Position
      // Get address of field 'x'
%31 = getelementptr %30, 0
      // Store field 'x'
store %31, 15 (u32)
      // Get address of field 'y'
%32 = getelementptr %30, 2
      // Store field 'y'
store %32, 25 (u32)
      // Alias struct value to alloca
%2 = %30 (*Position)
      // Lowered struct alloca for %3
%33 = framealloc Character
      // Get address of field 'health'
%34 = getelementptr %33, 0
      // Store field 'health'
store %34, 80 (u32)
      // Get address of field 'mana'
%35 = getelementptr %33, 2
      // Store field 'mana'
store %35, 30 (u32)
      // Get address of field 'level'
%36 = getelementptr %33, 4
      // Store field 'level'
store %36, 4 (u32)
      // Get address of field 'position'
%37 = getelementptr %33, 6
      // Store field 'position'
store %37, %2 (Position)
      // Alias struct value to alloca
%3 = %33 (*Character)
      %4 = 1 (u32)
      %5 = 10 (u32)
      jump 1

    1 (block_1):
      ; block_1
      %6 = %4 U32Greater %5
      if %6 then jump 3 else jump 4

    2 (block_2):
      ; block_2
      return 0

    3 (block_3):
      ; block_3
      jump 2

    4 (block_4):
      ; block_4
      %7 = call 5(%1, %3)
      if %7 U32Eq 1 then jump 5 else jump 6

    5 (block_5):
      ; block_5
      return 1

    6 (block_6):
      ; block_6
      if %7 U32Eq 2 then jump 7 else jump 8

    7 (block_7):
      ; block_7
      return 2

    8 (block_8):
      ; block_8
      jump 9

    9 (block_9):
      ; block_9
      // Get address of field 'health' (lowered)
%38 = getelementptr %25, 0
      // Load field 'health' (lowered)
%10 = load u32 %38
      %11 = %10 U32Greater 10
      if %11 then jump 10 else jump 11

    10 (block_10):
      ; block_10
      // Get address of field 'health' (lowered)
%39 = getelementptr %25, 0
      // Load field 'health' (lowered)
%12 = load u32 %39
      %13 = %12 U32Sub 5
      // Get address of field 'health'
%14 = getelementptr %1, 0
      store %14, %13 (u32)
      jump 11

    11 (block_11):
      ; block_11
      // Get address of field 'health' (lowered)
%40 = getelementptr %33, 0
      // Load field 'health' (lowered)
%15 = load u32 %40
      %16 = %15 U32Greater 8
      if %16 then jump 12 else jump 13

    12 (block_12):
      ; block_12
      // Get address of field 'health' (lowered)
%41 = getelementptr %33, 0
      // Load field 'health' (lowered)
%17 = load u32 %41
      %18 = %17 U32Sub 4
      // Get address of field 'health'
%19 = getelementptr %3, 0
      store %19, %18 (u32)
      jump 13

    13 (block_13):
      ; block_13
      %20 = %4 U32Add 1
      store %4, %20 (u32)
      jump 1

  }

}
