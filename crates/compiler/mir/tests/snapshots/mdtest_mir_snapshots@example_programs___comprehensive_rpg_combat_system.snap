---
source: crates/compiler/mir/tests/mdtest_snapshots.rs
description: "MIR snapshot for mdtest: Example Programs - Comprehensive RPG Combat System"
input_file: mdtest/07-example-programs/example-00.md
---
Source:
// Struct definitions showing custom types
struct Character {
    health: u32,
    mana: u32,
    level: u32,
    position: Position,
}

struct Position {
    x: u32,
    y: u32,
}

struct CombatResult {
    damage_dealt: u32,
    critical_hit: bool,
    remaining_health: u32,
}


// Entry point demonstrating tuple usage and multiple features
fn main_test() -> u32 {
    let battle_result = simulate_full_battle();

    // Create a summary tuple
    let summary = get_character_stats(Character {
        health: 100,
        mana: 50,
        level: 5,
        position: Position { x: 0, y: 0 },
    });

    // Extract tuple values
    let (health, mana, level) = summary;

    // Combine results using both felt and u32 arithmetic
    let final_score: u32 = battle_result + level;  // u32 + u32 in felt context
    let bonus_score = mana / 10u32;  // felt arithmetic

    return final_score + bonus_score;
}


// Function demonstrating tuples as return types
fn get_character_stats(char: Character) -> (u32, u32, u32) {
    return (char.health, char.mana, char.level);
}

// Function with complex struct manipulation and arithmetic
fn calculate_distance_squared(pos1: Position, pos2: Position) -> u32 {
    let dx = pos1.x - pos2.x;
    let dy = pos1.y - pos2.y;
    return dx * dx + dy * dy;
}

// Function demonstrating control flow and u32/felt operations
fn calculate_damage(attacker_level: u32, defender_level: u32, distance: u32) -> u32 {
    let base_damage: u32 = 10;
    let level_bonus = attacker_level * 2;

    // Convert felt to rough u32 for distance penalty (simplified)
    let distance_penalty: u32 = 0;
    if (distance > 100) {
        distance_penalty = 5;
    } else {
        if (distance > 50) {
            distance_penalty = 2;
        }
    }

    let total_damage = base_damage + level_bonus;
    if (total_damage > distance_penalty) {
        return total_damage - distance_penalty;
    } else {
        return 1;  // Minimum damage
    }
}

// Function showing loops and complex logic
fn perform_combat(attacker: Character, defender: Character) -> CombatResult {
    let distance = calculate_distance_squared(attacker.position, defender.position);
    let base_damage = calculate_damage(attacker.level, defender.level, distance);

    // Critical hit calculation using felt arithmetic
    let critical_multiplier = attacker.mana / 10u32;  // u32 division
    let is_critical: bool = false;
    let final_damage = base_damage;

    if (critical_multiplier > 5) {
        is_critical = true;
        final_damage = base_damage * 2;
    }

    // Apply damage with bounds checking
    let new_health = defender.health;
    if (final_damage >= defender.health) {
        new_health = 0;
    } else {
        new_health = defender.health - final_damage;
    }

    let res = CombatResult {
        damage_dealt: final_damage,
        critical_hit: is_critical,
        remaining_health: new_health,
    };
    return res;
}

// Function demonstrating multiple function calls and tuple destructuring
fn simulate_battle_round(hero: Character, enemy: Character) -> u32 {
    // Hero attacks enemy
    let hero_attack = perform_combat(hero, enemy);
    let enemy_health = hero_attack.remaining_health;

    // Enemy counter-attacks if still alive
    if (enemy_health > 0) {
        let enemy_counter = perform_combat(enemy, hero);
        let hero_health = enemy_counter.remaining_health;

        // Return 1 if hero wins, 2 if enemy wins, 0 if both alive
        if (enemy_health == 0) {
            return 1;  // Hero wins
        } else {
            if (hero_health == 0) {
                return 2;  // Enemy wins
            } else {
                return 0;  // Both alive, continue battle
            }
        }
    } else {
        return 1;  // Hero wins immediately
    }
}

// Main function demonstrating variable mutation and comprehensive example
fn simulate_full_battle() -> u32 {
    // Create characters using struct literals
    let hero = Character {
        health: 100,
        mana: 50,
        level: 5,
        position: Position { x: 10, y: 20 },
    };

    let enemy = Character {
        health: 80,
        mana: 30,
        level: 4,
        position: Position { x: 15, y: 25 },
    };

    // Battle loop with mutation
    let current_hero = hero;
    let current_enemy = enemy;
    let round: u32 = 1;
    let max_rounds: u32 = 10;

    // Simulate multiple battle rounds
    loop {
        if (round > max_rounds) {
            break;  // Draw after max rounds
        }

        let result = simulate_battle_round(current_hero, current_enemy);

        if (result == 1) {
            return 1;  // Hero victory
        } else {
            if (result == 2) {
                return 2;  // Enemy victory
            }
        }

        // Update for next round (simplified - reduce both healths)
        if (current_hero.health > 10) {
            current_hero.health = current_hero.health - 5;
        }
        if (current_enemy.health > 8) {
            current_enemy.health = current_enemy.health - 4;
        }

        round = round + 1;
    }

    return 0;  // Draw
}
============================================================
Generated MIR:
module {
  // Function 0
  fn main_test {
    entry: 0

    0:
      %0 = call 6()
      // Allocate struct
%1 = framealloc Character
      // Get address of field 'health'
%2 = getelementptr %1, 0
      store %2, 100 (u32)
      // Get address of field 'mana'
%3 = getelementptr %1, 2
      store %3, 50 (u32)
      // Get address of field 'level'
%4 = getelementptr %1, 4
      store %4, 5 (u32)
      // Allocate struct
%5 = framealloc Position
      // Get address of field 'x'
%6 = getelementptr %5, 0
      store %6, 0 (u32)
      // Get address of field 'y'
%7 = getelementptr %5, 2
      store %7, 0 (u32)
      // Get address of field 'position'
%8 = getelementptr %1, 6
      store %8, %5 (Position)
      %9, %10, %11 = call 1(%1)
      // Allocate space for tuple return value
%12 = framealloc (u32, u32, u32)
      // Get address of tuple element 0
%13 = getelementptr %12, 0
      store %13, %9 (u32)
      // Get address of tuple element 1
%14 = getelementptr %12, 1
      store %14, %10 (u32)
      // Get address of tuple element 2
%15 = getelementptr %12, 2
      store %15, %11 (u32)
      // Load variable summary
%16 = load (u32, u32, u32) %12
      // Get address of tuple element 1
%18 = getelementptr %16, 1
      // Load tuple element 1
%19 = load u32 %18
      // Get address of tuple element 2
%20 = getelementptr %16, 2
      // Load tuple element 2
%21 = load u32 %20
      %22 = %0 U32Add %21
      %23 = %19 U32Div 10
      %24 = %22 U32Add %23
      return %24

  }

  // Function 1
  fn get_character_stats {
    parameters: [0]
    entry: 0

    0:
      // Get address of field 'health'
%1 = getelementptr %0, 0
      // Load field 'health'
%2 = load u32 %1
      // Get address of field 'mana'
%3 = getelementptr %0, 2
      // Load field 'mana'
%4 = load u32 %3
      // Get address of field 'level'
%5 = getelementptr %0, 4
      // Load field 'level'
%6 = load u32 %5
      return (%2, %4, %6)

  }

  // Function 2
  fn calculate_distance_squared {
    parameters: [0, 1]
    entry: 0

    0:
      // Get address of field 'x'
%2 = getelementptr %0, 0
      // Load field 'x'
%3 = load u32 %2
      // Get address of field 'x'
%4 = getelementptr %1, 0
      // Load field 'x'
%5 = load u32 %4
      %6 = %3 U32Sub %5
      // Get address of field 'y'
%7 = getelementptr %0, 2
      // Load field 'y'
%8 = load u32 %7
      // Get address of field 'y'
%9 = getelementptr %1, 2
      // Load field 'y'
%10 = load u32 %9
      %11 = %8 U32Sub %10
      %12 = %6 U32Mul %6
      %13 = %11 U32Mul %11
      %14 = %12 U32Add %13
      return %14

  }

  // Function 3
  fn calculate_damage {
    parameters: [0, 1, 2]
    entry: 0

    0:
      %3 = 10 (u32)
      %4 = %0 U32Mul 2
      %5 = 0 (u32)
      %6 = %2 U32Greater 100
      if %6 then jump 1 else jump 2

    1 (block_1):
      ; block_1
      store %5, 5 (u32)
      jump 5

    2 (block_2):
      ; block_2
      %7 = %2 U32Greater 50
      if %7 then jump 3 else jump 4

    3 (block_3):
      ; block_3
      store %5, 2 (u32)
      jump 4

    4 (block_4):
      ; block_4
      jump 5

    5 (block_5):
      ; block_5
      %8 = %3 U32Add %4
      %9 = %8 U32Greater %5
      if %9 then jump 6 else jump 7

    6 (block_6):
      ; block_6
      %10 = %8 U32Sub %5
      return %10

    7 (block_7):
      ; block_7
      return 1

  }

  // Function 4
  fn perform_combat {
    parameters: [0, 1]
    entry: 0

    0:
      // Get address of field 'position'
%2 = getelementptr %0, 6
      // Load field 'position'
%3 = load Position %2
      // Get address of field 'position'
%4 = getelementptr %1, 6
      // Load field 'position'
%5 = load Position %4
      %6 = call 2(%3, %5)
      // Get address of field 'level'
%7 = getelementptr %0, 4
      // Load field 'level'
%8 = load u32 %7
      // Get address of field 'level'
%9 = getelementptr %1, 4
      // Load field 'level'
%10 = load u32 %9
      %11 = call 3(%8, %10, %6)
      // Get address of field 'mana'
%12 = getelementptr %0, 2
      // Load field 'mana'
%13 = load u32 %12
      %14 = %13 U32Div 10
      %15 = false (bool)
      %16 = %14 U32Greater 5
      if %16 then jump 1 else jump 2

    1 (block_1):
      ; block_1
      store %15, true (bool)
      %17 = %11 U32Mul 2
      store %11, %17 (u32)
      jump 2

    2 (block_2):
      ; block_2
      // Get address of field 'health'
%18 = getelementptr %1, 0
      // Load field 'health'
%19 = load u32 %18
      // Get address of field 'health'
%20 = getelementptr %1, 0
      // Load field 'health'
%21 = load u32 %20
      %22 = %11 U32GreaterEqual %21
      if %22 then jump 3 else jump 4

    3 (block_3):
      ; block_3
      store %19, 0
      jump 5

    4 (block_4):
      ; block_4
      // Get address of field 'health'
%23 = getelementptr %1, 0
      // Load field 'health'
%24 = load u32 %23
      %25 = %24 U32Sub %11
      store %19, %25 (u32)
      jump 5

    5 (block_5):
      ; block_5
      // Allocate struct
%26 = framealloc CombatResult
      // Get address of field 'damage_dealt'
%27 = getelementptr %26, 0
      store %27, %11 (u32)
      // Get address of field 'critical_hit'
%28 = getelementptr %26, 2
      store %28, %15 (bool)
      // Get address of field 'remaining_health'
%29 = getelementptr %26, 3
      store %29, %19 (u32)
      // Load variable res
%30 = load CombatResult %26
      return %30

  }

  // Function 5
  fn simulate_battle_round {
    parameters: [0, 1]
    entry: 0

    0:
      %2 = call 4(%0, %1)
      // Get address of field 'remaining_health'
%3 = getelementptr %2, 3
      // Load field 'remaining_health'
%4 = load u32 %3
      %5 = %4 U32Greater 0
      if %5 then jump 1 else jump 2

    1 (block_1):
      ; block_1
      %6 = call 4(%1, %0)
      // Get address of field 'remaining_health'
%7 = getelementptr %6, 3
      // Load field 'remaining_health'
%8 = load u32 %7
      if %4 then jump 4 else jump 3

    2 (block_2):
      ; block_2
      return 1

    3 (block_3):
      ; block_3
      return 1

    4 (block_4):
      ; block_4
      if %8 then jump 6 else jump 5

    5 (block_5):
      ; block_5
      return 2

    6 (block_6):
      ; block_6
      return 0

  }

  // Function 6
  fn simulate_full_battle {
    entry: 0

    0:
      // Allocate struct
%0 = framealloc Character
      // Get address of field 'health'
%1 = getelementptr %0, 0
      store %1, 100 (u32)
      // Get address of field 'mana'
%2 = getelementptr %0, 2
      store %2, 50 (u32)
      // Get address of field 'level'
%3 = getelementptr %0, 4
      store %3, 5 (u32)
      // Allocate struct
%4 = framealloc Position
      // Get address of field 'x'
%5 = getelementptr %4, 0
      store %5, 10 (u32)
      // Get address of field 'y'
%6 = getelementptr %4, 2
      store %6, 20 (u32)
      // Get address of field 'position'
%7 = getelementptr %0, 6
      store %7, %4 (Position)
      // Allocate struct
%8 = framealloc Character
      // Get address of field 'health'
%9 = getelementptr %8, 0
      store %9, 80 (u32)
      // Get address of field 'mana'
%10 = getelementptr %8, 2
      store %10, 30 (u32)
      // Get address of field 'level'
%11 = getelementptr %8, 4
      store %11, 4 (u32)
      // Allocate struct
%12 = framealloc Position
      // Get address of field 'x'
%13 = getelementptr %12, 0
      store %13, 15 (u32)
      // Get address of field 'y'
%14 = getelementptr %12, 2
      store %14, 25 (u32)
      // Get address of field 'position'
%15 = getelementptr %8, 6
      store %15, %12 (Position)
      // Load variable hero
%16 = load Character %0
      // Load variable enemy
%17 = load Character %8
      %18 = 1 (u32)
      %19 = 10 (u32)
      jump 1

    1 (block_1):
      ; block_1
      %20 = %18 U32Greater %19
      if %20 then jump 3 else jump 4

    2 (block_2):
      ; block_2
      return 0

    3 (block_3):
      ; block_3
      jump 2

    4 (block_4):
      ; block_4
      %21 = call 5(%16, %17)
      if %21 U32Eq 1 then jump 5 else jump 6

    5 (block_5):
      ; block_5
      return 1

    6 (block_6):
      ; block_6
      if %21 U32Eq 2 then jump 7 else jump 8

    7 (block_7):
      ; block_7
      return 2

    8 (block_8):
      ; block_8
      jump 9

    9 (block_9):
      ; block_9
      // Get address of field 'health'
%24 = getelementptr %16, 0
      // Load field 'health'
%25 = load u32 %24
      %26 = %25 U32Greater 10
      if %26 then jump 10 else jump 11

    10 (block_10):
      ; block_10
      // Get address of field 'health'
%27 = getelementptr %16, 0
      // Load field 'health'
%28 = load u32 %27
      %29 = %28 U32Sub 5
      // Get address of field 'health'
%30 = getelementptr %16, 0
      store %30, %29 (u32)
      jump 11

    11 (block_11):
      ; block_11
      // Get address of field 'health'
%31 = getelementptr %17, 0
      // Load field 'health'
%32 = load u32 %31
      %33 = %32 U32Greater 8
      if %33 then jump 12 else jump 13

    12 (block_12):
      ; block_12
      // Get address of field 'health'
%34 = getelementptr %17, 0
      // Load field 'health'
%35 = load u32 %34
      %36 = %35 U32Sub 4
      // Get address of field 'health'
%37 = getelementptr %17, 0
      store %37, %36 (u32)
      jump 13

    13 (block_13):
      ; block_13
      %38 = %18 U32Add 1
      store %18, %38 (u32)
      jump 1

  }

}
