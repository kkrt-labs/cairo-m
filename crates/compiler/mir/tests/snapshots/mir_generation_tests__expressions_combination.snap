---
source: crates/compiler/mir/tests/mir_generation_tests.rs
expression: snapshot_content
---
---
source: crates/compiler/mir/tests/mir_generation_tests.rs
expression: mir_output
---
Fixture: combination.cm
============================================================
Source code:
fn main() -> felt {
    let x = 3;
    let y = 13;
    let even_number = 16;
    let eq = x == y;
    let mut_val = 1;
    let eq_felt = 0;
    if (eq){
        eq_felt = 1;
        mut_val = mut_val + eq_felt + 1;
    }
    mut_val = mut_val * mut_val;
    mut_val = mut_val + (even_number / 2);

    let eq2 = (x == 3);
    let eq2_felt = 0;
    if (eq2){
        eq2_felt = 1;
    }

    let tempvar = 0;
    if (y == 3) {
        tempvar = 1;
    }
    let compound1 = (x != 0) || ((tempvar) + 2 != 0);
    let compound1_felt = 0;
    if (compound1){
        compound1_felt = 1;
    }
    let compound2 = (eq_felt != 2) && (3 != 0);

    let compound2_felt = 0;
    if (compound2){
        compound2_felt = 1;
    }

    for (let i = 0; i != 3; i = i + 1) {
        mut_val = mut_val + i;
    }

    let (a, b) = foo();
    return mut_val + eq2_felt + a + bar() + b + compound1_felt + compound2_felt;
}

fn foo() -> (felt, felt) {
    return (32, 62);
}

fn bar() -> felt {
    return 123;
}

============================================================
Generated MIR:
module {
  // Function 0
  fn main {
    entry: 0

    0:
      %0 = 3
      %1 = 13
      %2 = 16
      %3 = %0 Eq %1
      %4 = 1
      %5 = 0
      if %3 then jump 1 else jump 2

    1:
      store %5, 1
      %6 = %4 Add %5
      %7 = %6 Add 1
      store %4, %7
      jump 2

    2:
      %4 = %4 Mul %4
      %9 = %2 Div 2
      %4 = %4 Add %9
      %11 = %0 Eq 3
      %12 = 0
      if %11 then jump 3 else jump 4

    3:
      store %12, 1
      jump 4

    4:
      %13 = 0
      if %1 Eq 3 then jump 5 else jump 6

    5:
      store %13, 1
      jump 6

    6:
      %15 = %0 Neq 0
      %16 = %13 Add 2
      %17 = %16 Neq 0
      %18 = %15 Or %17
      %19 = 0
      if %18 then jump 7 else jump 8

    7:
      store %19, 1
      jump 8

    8:
      %20 = %5 Neq 2
      %21 = 3 Neq 0
      %22 = %20 And %21
      %23 = 0
      if %22 then jump 9 else jump 10

    9:
      store %23, 1
      jump 10

    10:
      %24 = 0
      jump 11

    11:
      if %24 Neq 3 then jump 12 else jump 14

    12:
      %4 = %4 Add %24
      jump 13

    13:
      %24 = %24 Add 1
      jump 11

    14:
      %28, %29 = call 1()
      %30 = %4 Add %12
      %31 = %30 Add %28
      %32 = call 2()
      %33 = %31 Add %32
      %34 = %33 Add %29
      %35 = %34 Add %19
      %36 = %35 Add %23
      return %36

  }

  // Function 1
  fn foo {
    entry: 0

    0:
      return (32, 62)

  }

  // Function 2
  fn bar {
    entry: 0

    0:
      return 123

  }

}
