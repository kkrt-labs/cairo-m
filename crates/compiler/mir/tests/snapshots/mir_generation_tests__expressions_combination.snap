---
source: crates/compiler/mir/tests/mir_generation_tests.rs
expression: snapshot_content
---
---
source: crates/compiler/mir/tests/mir_generation_tests.rs
expression: mir_output
---
Fixture: combination.cm
============================================================
Source code:
fn main() -> felt {
    let x = 3;
    let y = 13;
    let even_number = 16;
    let eq = x == y;
    let mut_val = 1;
    let eq_felt = 0;
    if (eq){
        eq_felt = 1;
        mut_val = mut_val + eq_felt + 1;
    }
    mut_val = mut_val * mut_val;
    mut_val = mut_val + (even_number / 2);

    let eq2 = (x == 3);
    let eq2_felt = 0;
    if (eq2){
        eq2_felt = 1;
    }

    let tempvar = 0;
    if (y == 3) {
        tempvar = 1;
    }
    let compound1 = (x != 0) || ((tempvar) + 2 != 0);
    let compound1_felt = 0;
    if (compound1){
        compound1_felt = 1;
    }
    let compound2 = (eq_felt != 2) && (3 != 0);

    let compound2_felt = 0;
    if (compound2){
        compound2_felt = 1;
    }

    for (let i = 0; i != 3; i = i + 1) {
        mut_val = mut_val + i;
    }

    let (a, b) = foo();
    return mut_val + eq2_felt + a + bar() + b + compound1_felt + compound2_felt;
}

fn foo() -> (felt, felt) {
    return (32, 62);
}

fn bar() -> felt {
    return 123;
}

============================================================
Generated MIR:
module {
  // Function 0
  fn main {
    entry: 0

    0:
      %0 = stackalloc 1
      store %0, 3
      %1 = stackalloc 1
      store %1, 13
      %2 = stackalloc 1
      store %2, 16
      %3 = stackalloc 1
      %3 = %0 Eq %1
      %4 = stackalloc 1
      store %4, 1
      %5 = stackalloc 1
      store %5, 0
      if %3 then jump 1 else jump 2

    1:
      store %5, 1
      %6 = %4 Add %5
      %4 = %6 Add 1
      jump 2

    2:
      %4 = %4 Mul %4
      %7 = %2 Div 2
      %4 = %4 Add %7
      %8 = stackalloc 1
      %8 = %0 Eq 3
      %9 = stackalloc 1
      store %9, 0
      if %8 then jump 3 else jump 4

    3:
      store %9, 1
      jump 4

    4:
      %10 = stackalloc 1
      store %10, 0
      if %1 Eq 3 then jump 5 else jump 6

    5:
      store %10, 1
      jump 6

    6:
      %12 = %0 Neq 0
      %13 = %10 Add 2
      %14 = %13 Neq 0
      %15 = stackalloc 1
      %15 = %12 Or %14
      %16 = stackalloc 1
      store %16, 0
      if %15 then jump 7 else jump 8

    7:
      store %16, 1
      jump 8

    8:
      %17 = %5 Neq 2
      %18 = 3 Neq 0
      %19 = stackalloc 1
      %19 = %17 And %18
      %20 = stackalloc 1
      store %20, 0
      if %19 then jump 9 else jump 10

    9:
      store %20, 1
      jump 10

    10:
      %21 = stackalloc 1
      store %21, 0
      jump 11

    11:
      if %21 Neq 3 then jump 12 else jump 14

    12:
      %4 = %4 Add %21
      jump 13

    13:
      %21 = %21 Add 1
      jump 11

    14:
      %23, %24 = call 1()
      %25 = %4 Add %9
      %26 = %25 Add %23
      %27 = call 2()
      %28 = %26 Add %27
      %29 = %28 Add %24
      %30 = %29 Add %16
      %31 = %30 Add %20
      return %31

  }

  // Function 1
  fn foo {
    entry: 0

    0:
      return (32, 62)

  }

  // Function 2
  fn bar {
    entry: 0

    0:
      return 123

  }

}
