---
source: crates/compiler/mir/tests/mdtest_snapshots.rs
description: "MIR snapshot for mdtest: Complex Expressions in Cairo-M - Comparison Operations"
input_file: mdtest/01-basics/06-expressions.md
---
Source:
fn test_comparisons() -> u32 {
    let a = 10u32;
    let b = 7u32;
    let c = 10u32;

    let eq = (a == c);        // true
    let ne = (a != b);        // true
    let lt = (b < a);         // true
    let le = (a <= c);        // true
    let gt = (a > b);         // true
    let ge = (c >= a);        // true

    let res = 0u32;
    if eq {
        res = res + 1u32;
    }
    if ne {
        res = res + 1u32;
    }
    if lt {
        res = res + 1u32;
    }
    if le {
        res = res + 1u32;
    }
    if gt {
        res = res + 1u32;
    }
    if ge {
        res = res + 1u32;
    }
    return res;
}
============================================================
Generated MIR:
module {
  // Function 0
  fn test_comparisons {
    entry: 0

    0:
      %0 = 10 (u32)
      %1 = 7 (u32)
      %2 = 10 (u32)
      %3 = %0 U32Eq %2
      %4 = %0 U32Neq %1
      %5 = %1 U32Less %0
      %6 = %0 U32LessEqual %2
      %7 = %0 U32Greater %1
      %8 = %2 U32GreaterEqual %0
      %9 = 0 (u32)
      %12 = %9 (u32)
      if %3 then jump 1 else jump 13

    1 (block_1):
      ; block_1
      %10 = %9 U32Add 1
      %12 = %10 (u32)
      jump 2

    2 (block_2):
      ; block_2
      %16 = %12 (u32)
      if %4 then jump 3 else jump 14

    3 (block_3):
      ; block_3
      %13 = %12 U32Add 1
      %16 = %13 (u32)
      jump 4

    4 (block_4):
      ; block_4
      %21 = %16 (u32)
      if %5 then jump 5 else jump 15

    5 (block_5):
      ; block_5
      %17 = %16 U32Add 1
      %21 = %17 (u32)
      jump 6

    6 (block_6):
      ; block_6
      %27 = %21 (u32)
      if %6 then jump 7 else jump 16

    7 (block_7):
      ; block_7
      %22 = %21 U32Add 1
      %27 = %22 (u32)
      jump 8

    8 (block_8):
      ; block_8
      %34 = %27 (u32)
      if %7 then jump 9 else jump 17

    9 (block_9):
      ; block_9
      %28 = %27 U32Add 1
      %34 = %28 (u32)
      jump 10

    10 (block_10):
      ; block_10
      %36 = %34 (u32)
      if %8 then jump 11 else jump 18

    11 (block_11):
      ; block_11
      %35 = %34 U32Add 1
      %36 = %35 (u32)
      jump 12

    12 (block_12):
      ; block_12
      return %36

    13 (edge_0_2):
      ; edge_0_2
      jump 2

    14 (edge_2_4):
      ; edge_2_4
      jump 4

    15 (edge_4_6):
      ; edge_4_6
      jump 6

    16 (edge_6_8):
      ; edge_6_8
      jump 8

    17 (edge_8_10):
      ; edge_8_10
      jump 10

    18 (edge_10_12):
      ; edge_10_12
      jump 12

  }

}
