---
source: crates/compiler/mir/src/ir_generation/tests/mir_generation_tests.rs
expression: snapshot_content
---
---
source: crates/compiler/mir/src/ir_generation/tests/mir_generation_tests.rs
expression: mir_output
---
Fixture: unused_variable_elimination.cm
============================================================
Source code:
// Test that unused variables don't generate allocations
fn test_unused(a: felt, b: felt) -> felt {
    let c = a + b;  // Used - should allocate
    let d = a * b;  // Unused - should NOT allocate
    let e = a == b; // Unused - should NOT allocate
    return c;
}

struct TestStruct {
    a: felt,
    b: felt,
}

fn test_unused_struct(a: felt, b: felt) -> felt {
    let s = TestStruct { a: a, b: b }; // Unused - should NOT allocate
    let s2 = TestStruct { a: a, b: b }; // Used - should allocate TODO: propagate unused variables so that this is also ignored
    let c = s2.a; // Unused - should NOT allocate
    return 0;
}


fn foo() -> felt {
    return 0;
}

fn test_unused_side_effect() -> felt {
    let y = 1 + 2; // Unused - should NOT allocate
    let x = foo() + 42; // Unused - should NOT allocate but should call foo
    return 0;
}

============================================================
Generated MIR:
module {
  // Function 0
  fn test_unused {
    parameters: [0, 1]
    entry: 0

    0:
      %2 = stackalloc 1
      %2 = %0 Add %1
      return %2

  }

  // Function 1
  fn test_unused_struct {
    parameters: [0, 1]
    entry: 0

    0:
      // Allocate struct
%3 = stackalloc 2
      // Get address of field 'a'
%4 = getelementptr %3, 0
      store %4, %0
      // Get address of field 'b'
%5 = getelementptr %3, 1
      store %5, %1
      return 0

  }

  // Function 2
  fn foo {
    entry: 0

    0:
      return 0

  }

  // Function 3
  fn test_unused_side_effect {
    entry: 0

    0:
      %1 = call 2()
      return 0

  }

}
