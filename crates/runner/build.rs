use std::path::Path;
use std::{env, fs};

fn main() {
    println!("cargo:rerun-if-changed=../../mdtest");

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("generated_tests.rs");

    // Use CARGO_MANIFEST_DIR to construct a robust path
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let workspace_root = Path::new(&manifest_dir)
        .parent() // crates/
        .and_then(|p| p.parent()) // workspace root
        .expect("Failed to find workspace root");

    let mdtest_dir = workspace_root.join("mdtest");

    if !mdtest_dir.exists() {
        fs::write(&dest_path, "// No mdtest directory found\n").unwrap();
        return;
    }

    let mut test_code = String::new();
    let mut test_files = Vec::new();

    // Discover all markdown files
    for entry in walkdir::WalkDir::new(&mdtest_dir)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.path().extension().and_then(|s| s.to_str()) == Some("md"))
    {
        test_files.push(entry.path().to_path_buf());
    }

    // Sort for deterministic output
    test_files.sort();

    for path in test_files {
        // Get relative path for module name
        let rel_path = path.strip_prefix(&mdtest_dir).unwrap();
        let path_parts: Vec<_> = rel_path
            .parent()
            .unwrap_or_else(|| Path::new(""))
            .components()
            .filter_map(|c| c.as_os_str().to_str())
            .collect();

        let file_stem = path.file_stem().unwrap().to_str().unwrap();

        // Create module name - ensure it starts with a letter
        let module_name = if path_parts.is_empty() {
            make_module_name(file_stem)
        } else {
            format!(
                "{}_{}",
                path_parts
                    .iter()
                    .map(|p| make_module_name(p))
                    .collect::<Vec<_>>()
                    .join("_"),
                make_module_name(file_stem)
            )
        };

        // Use the proper parser from test_utils
        let tests = match cairo_m_test_utils::mdtest::parser::extract_tests(&path) {
            Ok(tests) => tests,
            Err(e) => {
                eprintln!("Warning: Failed to parse {}: {}", path.display(), e);
                continue;
            }
        };

        if !tests.is_empty() {
            test_code.push_str(&format!("\n#[cfg(test)]\nmod {} {{\n", module_name));
            test_code.push_str("    use crate::common::{run_mdtest_diff, get_test_by_name};\n\n");

            // Track function names to avoid duplicates
            let mut function_names = std::collections::HashMap::new();

            for test in tests {
                // Extract H2 name from full test name for function name
                let h2_name = if let Some(pos) = test.name.rfind(" - ") {
                    &test.name[pos + 3..]
                } else {
                    &test.name
                };

                let base_fn_name = sanitize_name(h2_name);

                // Make function name unique if needed
                let counter = function_names.entry(base_fn_name.clone()).or_insert(0);
                *counter += 1;

                let fn_name = if *counter == 1 {
                    base_fn_name.clone()
                } else {
                    format!("{}_{}", base_fn_name, counter)
                };

                let should_ignore = test.metadata.ignore.is_some();

                if should_ignore {
                    test_code.push_str("    #[test]\n    #[ignore]\n");
                } else {
                    test_code.push_str("    #[test]\n");
                }

                test_code.push_str(&format!(
                    r#"    fn {}() {{
        let test = get_test_by_name("{}");
        if let Err(e) = run_mdtest_diff(test) {{
            panic!("Test failed: {{}}", e);
        }}
    }}
"#,
                    fn_name, test.name
                ));
            }

            test_code.push_str("}\n");
        }
    }

    // Write the generated code - no top-level imports to avoid namespace pollution
    let final_code = format!(
        r#"// Auto-generated test functions for markdown tests
// DO NOT EDIT - This file is generated by build.rs
{}
"#,
        test_code
    );

    fs::write(&dest_path, final_code).unwrap();
}

fn sanitize_name(s: &str) -> String {
    s.chars()
        .map(|c| {
            if c.is_alphanumeric() || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect::<String>()
        .to_lowercase()
}

fn make_module_name(s: &str) -> String {
    let sanitized = sanitize_name(s);
    // Module names can't start with a digit in Rust
    // Prefix with 'm_' (for 'module') if it starts with a number
    if sanitized.chars().next().is_some_and(|c| c.is_ascii_digit()) {
        format!("m_{}", sanitized)
    } else {
        sanitized
    }
}
