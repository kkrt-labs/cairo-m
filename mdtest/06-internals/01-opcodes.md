# Cairo-M Assembly Opcodes

This comprehensive test covers all Cairo-M assembly opcodes to ensure they
generate correct bytecode and execute properly. Cairo-M uses a minimal register
architecture with 32 different opcodes covering arithmetic, memory, control
flow, and U32 operations.

## Felt Arithmetic Operations

### Addition - StoreAddFpFp and StoreAddFpImm

Basic field addition operations:

```cairo-m
fn test_addition() -> felt {
    let a = 10;
    let b = 5;

    // StoreAddFpFp: [fp + dst_off] = [fp + src0_off] + [fp + src1_off]
    let sum1 = a + b;

    // StoreAddFpImm: [fp + dst_off] = [fp + src_off] + imm
    let sum2 = a + 3;

    return sum1 + sum2;
}
```

### Subtraction - StoreSubFpFp and StoreSubFpImm

Field subtraction operations:

```cairo-m
fn test_subtraction() -> felt {
    let a = 15;
    let b = 7;

    // StoreSubFpFp: [fp + dst_off] = [fp + src0_off] - [fp + src1_off]
    let diff1 = a - b;

    // StoreSubFpImm: [fp + dst_off] = [fp + src_off] - imm
    let diff2 = a - 2;

    return diff1 - diff2;
}
```

### Multiplication - StoreMulFpFp and StoreMulFpImm

Field multiplication operations:

```cairo-m
fn test_multiplication() -> felt {
    let a = 6;
    let b = 4;

    // StoreMulFpFp: [fp + dst_off] = [fp + src0_off] * [fp + src1_off]
    let prod1 = a * b;

    // StoreMulFpImm: [fp + dst_off] = [fp + src_off] * imm
    let prod2 = a * 3;

    return prod1 * prod2;
}
```

### Division - StoreDivFpFp and StoreDivFpImm

Field division using multiplicative inverse:

```cairo-m
fn test_division() -> felt {
    let a = 20;
    let b = 4;

    // StoreDivFpFp: [fp + dst_off] = [fp + src0_off] / [fp + src1_off]
    let div1 = a / b;

    // StoreDivFpImm: [fp + dst_off] = [fp + src_off] / imm
    let div2 = a / 2;

    return div1 + div2;
}
```

## Memory Operations

### Immediate Store - StoreImm

Direct immediate value storage:

```cairo-m
fn test_immediate_store() -> felt {
    // StoreImm: [fp + dst_off] = imm
    let immediate = 42;
    let another = 100;

    return immediate + another;
}
```

<!--
### Double Dereference - StoreDoubleDerefFp

Indirect memory access through pointer:

```cairo-m
//! ignore: Deref operator not implemented yet
fn test_double_deref() -> felt {
    let value = 123;
    let ptr = &value;

    // StoreDoubleDerefFp: [fp + dst_off] = [[fp + base_off] + offset]
    let deref_value = *ptr;

    return deref_value;
}
``` -->

## Control Flow Operations

### Function Calls - CallAbsImm and Ret

Function call and return operations:

```cairo-m
fn test_function_calls() -> felt {
    // CallAbsImm: call absolute immediate
    let result = helper_function();
    return result;
}

fn helper_function() -> felt {
    // Ret: return instruction
    return 42;
}
```

### Unconditional Jumps - JmpAbsImm and JmpRelImm

Jump operations for control flow:

```cairo-m
fn test_unconditional_jumps() -> felt {
    let result = 0;

    // JmpAbsImm and JmpRelImm are generated by loop constructs
    loop {
        result = result + 1;
        if result == 5 {
            break;
        }
    }

    return result;
}
```

### Conditional Jumps - JnzFpImm

Jump if non-zero condition:

```cairo-m
fn test_conditional_jumps() -> felt {
    let x = 10;
    let result = 0;

    // JnzFpImm: jump relative immediate if [fp + cond_off] != 0
    if x != 0 {
        result = 100;
    }

    if x == 5 {
        result = 200;
    } else {
        result = result + 50;
    }

    return result;
}
```

<!-- TODO: investigate & fix those failures. -->

<!-- ## U32 Arithmetic Operations

### U32 Addition - U32StoreAddFpFp and U32StoreAddFpImm

32-bit unsigned integer addition:

```cairo-m
fn test_u32_addition() -> u32 {
    let a: u32 = 100;
    let b: u32 = 50;

    // U32StoreAddFpFp: u32([fp + dst_off], [fp + dst_off + 1]) = u32([fp + src0_off], [fp + src0_off + 1]) + u32([fp + src1_off], [fp + src1_off + 1])
    let sum1: u32 = a + b;

    // U32StoreAddFpImm: u32([fp + dst_off], [fp + dst_off + 1]) = u32([fp + src_off], [fp + src_off + 1]) + u32(imm_lo, imm_hi)
    let sum2: u32 = a + 25;

    return sum1 + sum2;
}
```

### U32 Subtraction - U32StoreSubFpFp and U32StoreSubFpImm

32-bit unsigned integer subtraction:

```cairo-m
fn test_u32_subtraction() -> u32 {
    let a: u32 = 200;
    let b: u32 = 75;

    // U32StoreSubFpFp: u32([fp + dst_off], [fp + dst_off + 1]) = u32([fp + src0_off], [fp + src0_off + 1]) - u32([fp + src1_off], [fp + src1_off + 1])
    let diff1: u32 = a - b;

    // U32StoreSubFpImm: u32([fp + dst_off], [fp + dst_off + 1]) = u32([fp + src_off], [fp + src_off + 1]) - u32(imm_lo, imm_hi)
    let diff2: u32 = a - 50;

    return diff1 - diff2;
}
```

```rust
use std::num::Wrapping;

fn test_u32_subtraction() -> u32 {
    let a: u32 = 200;
    let b: u32 = 75;

    let diff1: u32 = a.wrapping_sub(b);
    let diff2: u32 = a.wrapping_sub(50);

    return diff1.wrapping_sub(diff2);
}
```

### U32 Multiplication - U32StoreMulFpFp and U32StoreMulFpImm

32-bit unsigned integer multiplication:

```cairo-m
fn test_u32_multiplication() -> u32 {
    let a: u32 = 12;
    let b: u32 = 8;

    // U32StoreMulFpFp: u32([fp + dst_off], [fp + dst_off + 1]) = u32([fp + src0_off], [fp + src0_off + 1]) * u32([fp + src1_off], [fp + src1_off + 1])
    let prod1: u32 = a * b;

    // U32StoreMulFpImm: u32([fp + dst_off], [fp + dst_off + 1]) = u32([fp + src_off], [fp + src_off + 1]) * u32(imm_lo, imm_hi)
    let prod2: u32 = a * 3;

    return prod1 * prod2;
}
```

### U32 Division - U32StoreDivFpFp and U32StoreDivFpImm

32-bit unsigned integer division:

```cairo-m
fn test_u32_division() -> u32 {
    let a: u32 = 100;
    let b: u32 = 5;

    // U32StoreDivFpFp: u32([fp + dst_off], [fp + dst_off + 1]) = u32([fp + src0_off], [fp + src0_off + 1]) / u32([fp + src1_off], [fp + src1_off + 1])
    let div1: u32 = a / b;

    // U32StoreDivFpImm: u32([fp + dst_off], [fp + dst_off + 1]) = u32([fp + src_off], [fp + src_off + 1]) / u32(imm_lo, imm_hi)
    let div2: u32 = a / 4;

    return div1 + div2;
}
```

### U32 Immediate Store - U32StoreImm

Store immediate 32-bit values:

```cairo-m
fn test_u32_immediate_store() -> u32 {
    // U32StoreImm: u32([fp + dst_off], [fp + dst_off + 1]) = u32(imm_lo, imm_hi)
    let immediate: u32 = 0xDEADBEEF;
    let small_val: u32 = 42;

    return immediate + small_val;
}
```

## Complex Opcode Combinations

### Mixed Arithmetic and Control Flow

Combining multiple opcode types in realistic scenarios:

```cairo-m
//! ignore: U32Eq not implemented yet
fn test_mixed_operations() -> u32 {
    let counter: u32 = 0;
    let sum: u32 = 0;
    let multiplier: u32 = 3;

    // Loop combining JnzFpImm, StoreAddFpFp, StoreAddFpImm, StoreMulFpImm
    loop {
        counter = counter + 1u32;
        sum = sum + (counter * multiplier);

        if counter == 5u32 {
            break;
        }
    }

    // Conditional with division
    if sum > 50u32 {
        sum = sum / 2;
    }

    return sum;
}
```

### Function Call Chain

Testing call/return opcodes with parameter passing:

```cairo-m
fn test_call_chain() -> felt {
    let a = 10;
    let b = 20;

    let result = add_and_multiply(a, b, 3);
    return result;
}

fn add_and_multiply(x: felt, y: felt, factor: felt) -> felt {
    let sum = x + y;
    let product = sum * factor;

    return compute_final(product, 5);
}

fn compute_final(value: felt, adjustment: felt) -> felt {
    return value + adjustment;
}
```

### Memory Access Patterns

Testing various memory operation combinations:

```cairo-m
fn test_memory_patterns() -> u32 {
    // Store immediates
    let base_value: u32 = 100;
    let offset: u32 = 5;

    // Arithmetic operations creating intermediate values
    let intermediate1 = base_value * 2u32;
    let intermediate2 = base_value + offset;
    let intermediate3 = intermediate1 - intermediate2;

    // Complex expression combining multiple operations
    let final_result = (intermediate3 + 50u32) / 3u32;

    return final_result;
}
``` -->
